import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Web Sockets","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-5-networking/websockets.md","filePath":"system-design/step-5-networking/websockets.md"}');
const _sfc_main = { name: "system-design/step-5-networking/websockets.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="web-sockets" tabindex="-1">Web Sockets <a class="header-anchor" href="#web-sockets" aria-label="Permalink to &quot;Web Sockets&quot;">​</a></h1><p>সাধারণ HTTP রিকোয়েস্ট হলো একমুখী (Unary), যেখানে ব্রাউজার রিকোয়েস্ট করলে সার্ভার রেসপন্স দেয়। কিন্তু <strong>Web Sockets</strong> আমাদের দ্বিমুখী (Bidirectional) এবং ফুল-ডুপ্লেক্স যোগাযোগের সুবিধা দেয়।</p><h2 id="_1-web-sockets-কি" tabindex="-1">1. Web Sockets কি? <a class="header-anchor" href="#_1-web-sockets-কি" aria-label="Permalink to &quot;1. Web Sockets কি?&quot;">​</a></h2><p>ওয়েব সকেট হলো একটি লং-লিভড (Long-lived) কানেকশন যা একবার স্থাপন হয়ে গেলে ক্লায়েন্ট এবং সার্ভার উভয়েই যেকোনো সময় একে অপরকে ডেটা পাঠাতে পারে। এটি TCP এর ওপর ভিত্তি করে চলে।</p><h2 id="_2-কেন-ওয়েব-সকেট-প্রয়োজন" tabindex="-1">2. কেন ওয়েব সকেট প্রয়োজন? <a class="header-anchor" href="#_2-কেন-ওয়েব-সকেট-প্রয়োজন" aria-label="Permalink to &quot;2. কেন ওয়েব সকেট প্রয়োজন?&quot;">​</a></h2><p>সাধারণ HTTP তে যদি সার্ভারে কোনো নতুন তথ্য থাকে, তবে ব্রাউজার তা জানতে পারে না যতক্ষণ না ব্রাউজার নিজে থেকে রিকোয়েস্ট পাঠায় (Polling)। ওয়েব সকেট এই সমস্যা সমাধান করে।</p><h3 id="ব্যবহারের-ক্ষেত্রসমূহ-use-cases" tabindex="-1">ব্যবহারের ক্ষেত্রসমূহ (Use Cases): <a class="header-anchor" href="#ব্যবহারের-ক্ষেত্রসমূহ-use-cases" aria-label="Permalink to &quot;ব্যবহারের ক্ষেত্রসমূহ (Use Cases):&quot;">​</a></h3><ul><li><strong>Chat Applications:</strong> রিয়েল-টাইম মেসেজ আদান-প্রদান (যেমন: WhatsApp, Messenger)।</li><li><strong>Live Sports Score:</strong> স্কিল সেকেন্ডের মধ্যে স্কোর আপডেট করা।</li><li><strong>Stock Market Dashboards:</strong> শেয়ারের দামের পরিবর্তন সাথে সাথে দেখানো।</li><li><strong>Multiplayer Games:</strong> গেমের মধ্যে প্লেয়ারদের মুভমেন্ট সিনক্রোনাইজ করা।</li></ul><h2 id="_3-কিভাবে-কাজ-করে-the-handshake" tabindex="-1">3. কিভাবে কাজ করে? (The Handshake) <a class="header-anchor" href="#_3-কিভাবে-কাজ-করে-the-handshake" aria-label="Permalink to &quot;3. কিভাবে কাজ করে? (The Handshake)&quot;">​</a></h2><p>ওয়েব সকেট কানেকশন শুরু হয় একটি সাধারণ HTTP রিকোয়েস্টের মাধ্যমে (Upgrade Header ব্যবহার করে)।</p><ol><li><strong>Request:</strong> ব্রাউজার বলে, &quot;আমি এই কানেকশনটি ওয়েব সকেটে ট্রান্সফার করতে চাই।&quot;</li><li><strong>Response:</strong> সার্ভার রাজি হলে 101 Switching Protocols স্ট্যাটাস পাঠিয়ে কানেকশনটি ওপেন রাখে।</li><li><strong>Communication:</strong> এরপর থেকে কোনো HTTP হেডার ছাড়াই সরাসরি বাইনারি বা টেক্সট ডেটা আদান-প্রদান হয়।</li></ol><h2 id="_4-web-sockets-বনাম-http-polling" tabindex="-1">4. Web Sockets বনাম HTTP Polling <a class="header-anchor" href="#_4-web-sockets-বনাম-http-polling" aria-label="Permalink to &quot;4. Web Sockets বনাম HTTP Polling&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="${ssrRenderStyle({ "text-align": "left" })}">বৈশিষ্ট্য</th><th style="${ssrRenderStyle({ "text-align": "left" })}">HTTP Polling</th><th style="${ssrRenderStyle({ "text-align": "left" })}">Web Sockets</th></tr></thead><tbody><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>কমিউনিকেশন</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">একমুখী (Client to Server)</td><td style="${ssrRenderStyle({ "text-align": "left" })}">দ্বিমুখী (Bidirectional)</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>ওভারহেড</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">অনেক বেশি (প্রতিবার হেডার যায়)</td><td style="${ssrRenderStyle({ "text-align": "left" })}">খুব কম (শুধুমাত্র ডেটা যায়)</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>ল্যাটেন্সি</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">বেশি</td><td style="${ssrRenderStyle({ "text-align": "left" })}">অনেক কম (Real-time)</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>কানেকশন</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">শর্ট-লিভড</td><td style="${ssrRenderStyle({ "text-align": "left" })}">লং-লিভড</td></tr></tbody></table><hr><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>ওয়েব সকেট সার্ভারের ওপর অনেক বেশি &#39;Open Connections&#39; এর চাপ তৈরি করে। তাই স্কেলিং করার সময় লোড ব্যালেন্সারে <strong>Sticky Sessions</strong> বা <strong>Redis Pub/Sub</strong> ব্যবহার করে বিভিন্ন সার্ভারের মধ্যে সিঙ্ক করা প্রয়োজন।</p></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-5-networking/websockets.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const websockets = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  websockets as default
};
