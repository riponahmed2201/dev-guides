import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Load Balancing Algorithms (Stateless & Stateful)","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-6-load-balancers/load-balancers.md","filePath":"system-design/step-6-load-balancers/load-balancers.md"}');
const _sfc_main = { name: "system-design/step-6-load-balancers/load-balancers.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="load-balancing-algorithms-stateless-stateful" tabindex="-1">Load Balancing Algorithms (Stateless &amp; Stateful) <a class="header-anchor" href="#load-balancing-algorithms-stateless-stateful" aria-label="Permalink to &quot;Load Balancing Algorithms (Stateless &amp; Stateful)&quot;">​</a></h1><p>একটি সিঙ্গেল সার্ভারের ক্ষমতা সীমিত। যখন ইউজারের সংখ্যা অনেক বেড়ে যায়, তখন অনেকগুলো সার্ভার মিলে রিকোয়েস্ট হ্যান্ডেল করতে হয়। এই রিকোয়েস্টগুলো কোন সার্ভারে যাবে তা ঠিক করাই হলো <strong>Load Balancer</strong> এর কাজ।</p><h2 id="_1-stateless-vs-stateful-load-balancing" tabindex="-1">1. Stateless vs Stateful Load Balancing <a class="header-anchor" href="#_1-stateless-vs-stateful-load-balancing" aria-label="Permalink to &quot;1. Stateless vs Stateful Load Balancing&quot;">​</a></h2><h3 id="stateless-load-balancing" tabindex="-1">Stateless Load Balancing <a class="header-anchor" href="#stateless-load-balancing" aria-label="Permalink to &quot;Stateless Load Balancing&quot;">​</a></h3><p>এখানে লোড ব্যালেন্সার প্রতিটি রিকোয়েস্টকে আলাদা হিসেবে দেখে। ইউজার আগে কোন সার্ভারে ছিল তার কোনো রেকর্ড রাখা হয় না।</p><ul><li><strong>সুবিধা:</strong> স্কেল করা খুব সহজ। কোনো সার্ভার ডাউন হলে অন্য সার্ভারে রিকোয়েস্ট পাঠানো যায় সহজেই।</li><li><strong>অসুবিধা:</strong> ইউজারের সেশন ডেটা (যেমন লগইন ইনফরমেশন) সব সার্ভারের এক্সেসযোগ্য হতে হয় (যেমন Redis বা Shared DB ব্যবহার করে)।</li></ul><h3 id="stateful-load-balancing-sticky-sessions" tabindex="-1">Stateful Load Balancing (Sticky Sessions) <a class="header-anchor" href="#stateful-load-balancing-sticky-sessions" aria-label="Permalink to &quot;Stateful Load Balancing (Sticky Sessions)&quot;">​</a></h3><p>এখানে লোড ব্যালেন্সার মনে রাখে যে ইউজারকে আগে কোন সার্ভারে পাঠানো হয়েছিল এবং পরবর্তী রিকোয়েস্টগুলো সেই নির্দিষ্ট সার্ভারেই পাঠায়।</p><ul><li><strong>সুবিধা:</strong> সেশন ডেটা সার্ভারের লোকাল মেমোরিতে রাখা যায়।</li><li><strong>অসুবিধা:</strong> যদি সেই নির্দিষ্ট সার্ভারটি ডাউন হয়ে যায়, তবে ইউজার সেশন রিমুভ হয়ে যায়। লোড ডিস্ট্রিবিউশন অসম হতে পারে।</li></ul><h2 id="_2-load-balancing-algorithms" tabindex="-1">2. Load Balancing Algorithms <a class="header-anchor" href="#_2-load-balancing-algorithms" aria-label="Permalink to &quot;2. Load Balancing Algorithms&quot;">​</a></h2><p>সার্ভার সিলেক্ট করার জন্য লোড ব্যালেন্সার বিভিন্ন অ্যালগরিদম ব্যবহার করে:</p><h3 id="static-algorithms-stateless" tabindex="-1">Static Algorithms (Stateless) <a class="header-anchor" href="#static-algorithms-stateless" aria-label="Permalink to &quot;Static Algorithms (Stateless)&quot;">​</a></h3><ol><li><strong>Round Robin:</strong> একের পর এক সার্ভারে রিকোয়েস্ট পাঠানো হয় (যেমন: সার্ভার ১ -&gt; ২ -&gt; ৩ -&gt; ১)।</li><li><strong>Weighted Round Robin:</strong> যে সার্ভারের ক্ষমতা বেশি, তাকে বেশি রিকোয়েস্ট পাঠানো হয়।</li><li><strong>IP Hash:</strong> ইউজারের আইপি অ্যাড্রেসের ওপর ভিত্তি করে একটি নির্দিষ্ট সার্ভার সিলেক্ট করা হয়।</li></ol><h3 id="dynamic-algorithms-stateful-aware" tabindex="-1">Dynamic Algorithms (Stateful/Aware) <a class="header-anchor" href="#dynamic-algorithms-stateful-aware" aria-label="Permalink to &quot;Dynamic Algorithms (Stateful/Aware)&quot;">​</a></h3><ol><li><strong>Least Connections:</strong> বর্তমানে যে সার্ভারে সবচেয়ে কম কানেকশন আছে, সেখানে রিকোয়েস্ট পাঠানো হয়।</li><li><strong>Least Response Time:</strong> যে সার্ভার সবচেয়ে দ্রুত রেসপন্স দিচ্ছে, তাকে প্রাধান্য দেওয়া হয়।</li></ol><hr><h2 id="কেন-লোড-ব্যালেন্সার-জরুরি" tabindex="-1">কেন লোড ব্যালেন্সার জরুরি? <a class="header-anchor" href="#কেন-লোড-ব্যালেন্সার-জরুরি" aria-label="Permalink to &quot;কেন লোড ব্যালেন্সার জরুরি?&quot;">​</a></h2><ul><li><strong>High Availability:</strong> একটি সার্ভার ডাউন হলেও পুরো সিস্টেম সচল থাকে।</li><li><strong>Scalability:</strong> ট্রাফিক বাড়লে খুব সহজেই নতুন সার্ভার যোগ করা যায়।</li><li><strong>Security:</strong> সরাসরি সার্ভারের আইপি এক্সপোজ না করে এটি একটি লেয়ার হিসেবে কাজ করে।</li></ul><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>আধুনিক ক্লাউড সিস্টেমে (যেমন AWS ALB বা Nginx) সাধারণত <strong>Round Robin</strong> বা <strong>Least Connections</strong> বেশি ব্যবহার করা হয়। সেশন সেন্ট্রালাইজড রাখার জন্য <strong>Redis</strong> ব্যবহার করা হলে স্টেটলেস আর্কিটেকচার সবচেয়ে ভালো পারফরম্যান্স দেয়।</p></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-6-load-balancers/load-balancers.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const loadBalancers = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  loadBalancers as default
};
