import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Asynchronous processing (Kafka, RabbitMQ)","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-7-message-queues/kafka-rabbitmq.md","filePath":"system-design/step-7-message-queues/kafka-rabbitmq.md"}');
const _sfc_main = { name: "system-design/step-7-message-queues/kafka-rabbitmq.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="asynchronous-processing-kafka-rabbitmq" tabindex="-1">Asynchronous processing (Kafka, RabbitMQ) <a class="header-anchor" href="#asynchronous-processing-kafka-rabbitmq" aria-label="Permalink to &quot;Asynchronous processing (Kafka, RabbitMQ)&quot;">​</a></h1><p>সিস্টেমের পারফরম্যান্স বাড়ানোর জন্য অনেক সময় আমরা রিকোয়েস্ট আসার সাথে সাথে প্রসেস না করে তা ব্যাকগ্রাউন্ডে করার জন্য রেখে দিই। একেই বলা হয় <strong>Asynchronous Processing</strong>। এটি করার জন্য <strong>Message Queue</strong> ব্যবহার করা হয়।</p><h2 id="_1-কেন-মেসেজ-কিউ-প্রয়োজন" tabindex="-1">1. কেন মেসেজ কিউ প্রয়োজন? <a class="header-anchor" href="#_1-কেন-মেসেজ-কিউ-প্রয়োজন" aria-label="Permalink to &quot;1. কেন মেসেজ কিউ প্রয়োজন?&quot;">​</a></h2><ul><li><strong>Decoupling:</strong> একটি সার্ভিস অন্যটির ওপর সরাসরি নির্ভরশীল থাকে না।</li><li><strong>Scalability:</strong> যদি অনেক বেশি রিকোয়েস্ট আসে, তবে তা কিউ-তে জমা থাকে এবং সার্ভার নিজের গতিতে তা প্রসেস করতে পারে।</li><li><strong>Reliability:</strong> যদি কোনো সার্ভার ডাউন থাকে, মেসেজ কিউ-তে ডেটা সযত্নে জমা থাকে (Persistent) এবং সার্ভার ঠিক হলে আবার প্রসেস শুরু হয়।</li><li><strong>Better User Experience:</strong> ইউজারকে লম্বা সময় ধরে অপেক্ষা করতে হয় না। যেমন: অর্ডার দেওয়ার পর ইমেইল ব্যাকগ্রাউন্ডে পাঠানো হয়।</li></ul><h2 id="_2-rabbitmq" tabindex="-1">2. RabbitMQ <a class="header-anchor" href="#_2-rabbitmq" aria-label="Permalink to &quot;2. RabbitMQ&quot;">​</a></h2><p>RabbitMQ হলো একটি ট্র্যাডিশনাল এবং অত্যন্ত জনপ্রিয় মেসেজ ব্রোকার।</p><ul><li><strong>বিমূর্ততা (Abstraction):</strong> এটি &quot;Smart Broker, Dumb Consumer&quot; মডেলে চলে। মানে ব্রোকার জানে কোন মেসেজ কার কাছে পাঠাতে হবে।</li><li><strong>Reliability:</strong> মেসেজ ডেলিভারি হওয়ার পর কিউ থেকে মুছে ফেলা হয় (Acknowledge)।</li><li><strong>ব্যবহার:</strong> যেখানে কমপ্লেক্স রাউটিং প্রয়োজন এবং মেসেজ দ্রুত ডেলিভারি হওয়া জরুরি।</li></ul><h2 id="_3-apache-kafka" tabindex="-1">3. Apache Kafka <a class="header-anchor" href="#_3-apache-kafka" aria-label="Permalink to &quot;3. Apache Kafka&quot;">​</a></h2><p>কাফকা শুধুমাত্র একটি মেসেজ কিউ নয়, এটি একটি <strong>Distributed Event Streaming Platform</strong>।</p><ul><li><strong>বিমূর্ততা (Abstraction):</strong> এটি &quot;Dumb Broker, Smart Consumer&quot; মডেলে চলে। কাফকা শুধু মেসেজগুলো সেভ করে রাখে, কনজিউমার নিজে ঠিক করে সে কতটুকু পড়েছে।</li><li><strong>High Throughput:</strong> এটি সেকেন্ডে লাখ লাখ মেসেজ হ্যান্ডেল করতে পারে।</li><li><strong>Persistence:</strong> এখানে মেসেজ ডেলিভারি হওয়ার পরও ডিলিট হয় না, বরং নির্দিষ্ট সময় পর্যন্ত সেভ থাকে (Log)। এটি ডেটা রিপ্লে (Replay) করার সুবিধা দেয়।</li><li><strong>ব্যবহার:</strong> লগ অ্যানালাইসিস, রিয়েল-টাইম ডেটা স্ট্রিমিং এবং ইভেন্ট সোর্সিং (Event Sourcing) এর জন্য।</li></ul><hr><h2 id="তুলনা-একনজরে" tabindex="-1">তুলনা একনজরে <a class="header-anchor" href="#তুলনা-একনজরে" aria-label="Permalink to &quot;তুলনা একনজরে&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="${ssrRenderStyle({ "text-align": "left" })}">বৈশিষ্ট্য</th><th style="${ssrRenderStyle({ "text-align": "left" })}">RabbitMQ</th><th style="${ssrRenderStyle({ "text-align": "left" })}">Apache Kafka</th></tr></thead><tbody><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>মডেল</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">Message Queue</td><td style="${ssrRenderStyle({ "text-align": "left" })}">Streaming Log</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>স্পিড/লোড</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">ভালো</td><td style="${ssrRenderStyle({ "text-align": "left" })}">অত্যন্ত হাই (Massive Scale)</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>মেসেজ রিটেনশন</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">ডেলিভারি হলে মুছে যায়</td><td style="${ssrRenderStyle({ "text-align": "left" })}">নির্দিষ্ট সময় পর্যন্ত থাকে</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>জটিলতা</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">মাঝারি</td><td style="${ssrRenderStyle({ "text-align": "left" })}">হাই (ম্যানেজ করা কঠিন)</td></tr></tbody></table><div class="tip custom-block github-alert"><p class="custom-block-title">TIP</p><p>যদি আপনার সাধারণ ব্যাকগ্রাউন্ড টাস্ক বা সার্ভিসগুলোর মধ্যে যোগাযোগের প্রয়োজন হয়, তবে <strong>RabbitMQ</strong> সহজ এবং কার্যকর। কিন্তু যদি বিশাল পরিমাণ ডেটা স্ট্রিমিং বা অ্যানালিটিক্স প্রয়োজন হয়, তবে <strong>Kafka</strong> সেরা।</p></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-7-message-queues/kafka-rabbitmq.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const kafkaRabbitmq = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  kafkaRabbitmq as default
};
