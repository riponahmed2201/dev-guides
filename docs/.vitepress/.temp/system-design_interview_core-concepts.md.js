import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"System Design Core Concepts: Theory & Q&A","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/interview/core-concepts.md","filePath":"system-design/interview/core-concepts.md"}');
const _sfc_main = { name: "system-design/interview/core-concepts.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="system-design-core-concepts-theory-q-a" tabindex="-1">System Design Core Concepts: Theory &amp; Q&amp;A <a class="header-anchor" href="#system-design-core-concepts-theory-q-a" aria-label="Permalink to &quot;System Design Core Concepts: Theory &amp; Q&amp;A&quot;">​</a></h1><p>সিস্টেম ডিজাইন ইন্টারভিউতে সবচেয়ে বেশি জিজ্ঞাসিত কোর কনসেপ্টগুলোর বিস্তারিত থিওরি এবং প্রশ্নোত্তর নিচে দেওয়া হলো।</p><hr><h2 id="১-স্কেলেবিলিটি-এভেইল্যাবিলিটি-এবং-রিলায়েবিলিটি" tabindex="-1">১. স্কেলেবিলিটি, এভেইল্যাবিলিটি এবং রিলায়েবিলিটি <a class="header-anchor" href="#১-স্কেলেবিলিটি-এভেইল্যাবিলিটি-এবং-রিলায়েবিলিটি" aria-label="Permalink to &quot;১. স্কেলেবিলিটি, এভেইল্যাবিলিটি এবং রিলায়েবিলিটি&quot;">​</a></h2><h3 id="ক-স্কেলেবিলিটি-scalability" tabindex="-1">ক. স্কেলেবিলিটি (Scalability) <a class="header-anchor" href="#ক-স্কেলেবিলিটি-scalability" aria-label="Permalink to &quot;ক. স্কেলেবিলিটি (Scalability)&quot;">​</a></h3><p><strong>থিওরি:</strong> স্কেলেবিলিটি হলো কোনো সিস্টেমের বাড়তি লোড বা ট্রাফিক হ্যান্ডেল করার ক্ষমতা। এটি প্রধানত দুই প্রকার:</p><ul><li><strong>Vertical Scaling:</strong> একটি পিসির রিসোর্স (CPU, RAM) বাড়ানো।</li><li><strong>Horizontal Scaling:</strong> সিস্টেমে আরও বেশি পিসি/সার্ভার যুক্ত করা।</li></ul><p><strong>প্রশ্ন:</strong> কখন আপনি Horizontal স্কেলিং পছন্দ করবেন? <strong>উত্তর:</strong> যখন সিস্টেমের গ্রোথ অনেক বেশি এবং একটি সিঙ্গেল সার্ভারের পাওয়ার বাড়ানো আর সম্ভব না (Limit reached), তখন Horizontal স্কেলিং সবচেয়ে ভালো সমাধান। এটি Redundancy নিশ্চিত করে এবং সিঙ্গেল পয়েন্ট অফ ফেইলিওর কমায়।</p><h3 id="খ-এভেইল্যাবিলিটি-availability" tabindex="-1">খ. এভেইল্যাবিলিটি (Availability) <a class="header-anchor" href="#খ-এভেইল্যাবিলিটি-availability" aria-label="Permalink to &quot;খ. এভেইল্যাবিলিটি (Availability)&quot;">​</a></h3><p><strong>থিওরি:</strong> সিস্টেমটি সব সময় ইউজারদের জন্য সচল থাকার ক্ষমতা। এটি সাধারণত &#39;nines&#39; দিয়ে প্রকাশ করা হয় (উদা: 99.99% availability)।</p><h3 id="গ-রিলায়েবিলিটি-reliability" tabindex="-1">গ. রিলায়েবিলিটি (Reliability) <a class="header-anchor" href="#গ-রিলায়েবিলিটি-reliability" aria-label="Permalink to &quot;গ. রিলায়েবিলিটি (Reliability)&quot;">​</a></h3><p><strong>থিওরি:</strong> সিস্টেমটি ভুল ছাড়াই নির্দিষ্ট সময়ে সঠিকভাবে কাজ করার ক্ষমতা। একটি রিলায়েবল সিস্টেম মানে হলো এটি ফেইল করবে না।</p><hr><h2 id="২-কনসিস্টেন্সি-মডেল-এবং-cap-theorem" tabindex="-1">২. কনসিস্টেন্সি মডেল এবং CAP Theorem <a class="header-anchor" href="#২-কনসিস্টেন্সি-মডেল-এবং-cap-theorem" aria-label="Permalink to &quot;২. কনসিস্টেন্সি মডেল এবং CAP Theorem&quot;">​</a></h2><h3 id="ক-কনসিস্টেন্সি-মডেল-consistency-models" tabindex="-1">ক. কনসিস্টেন্সি মডেল (Consistency Models) <a class="header-anchor" href="#ক-কনসিস্টেন্সি-মডেল-consistency-models" aria-label="Permalink to &quot;ক. কনসিস্টেন্সি মডেল (Consistency Models)&quot;">​</a></h3><ul><li><strong>Strong Consistency:</strong> ডেটা লেখার সাথে সাথেই সব রিড রিকোয়েস্টে আপডেট ভ্যালু পাওয়া যাবে। (উদা: ব্যাংকিং ট্রানজেকশন)।</li><li><strong>Eventual Consistency:</strong> ডেটা লেখার পর কিছু সময় লাগতে পারে সব জায়গায় আপডেট হতে, কিন্তু এক সময় সবাই আপডেট ভ্যালু পাবে। (উদা: ফেসবুক লাইক বা টুইট)।</li></ul><h3 id="খ-cap-theorem" tabindex="-1">খ. CAP Theorem <a class="header-anchor" href="#খ-cap-theorem" aria-label="Permalink to &quot;খ. CAP Theorem&quot;">​</a></h3><p><strong>থিওরি:</strong> ডিস্ট্রিবিউটেড সিস্টেমে Consistency (C), Availability (A), এবং Partition Tolerance (P) - এই তিনটির মধ্যে একসাথে সর্বোচ্চ দুইটি নিশ্চিত করা সম্ভব।</p><p><strong>প্রশ্ন:</strong> CAP থিউরেমে কেন Partition Tolerance (P) সবসময় বাধ্যতামূলক? <strong>উত্তর:</strong> একটি নেটওয়ার্ক সিস্টেমে যেকোনো সময় কানেকশন ব্রেক (Network Partition) হতে পারে। তাই ডিস্ট্রিবিউটেড সিস্টেমে আমাদের হয় CP (Consistency) বেছে নিতে হবে অথবা AP (Availability)।</p><hr><h2 id="৩-কনসিস্টেন্ট-হ্যাশিং-consistent-hashing" tabindex="-1">৩. কনসিস্টেন্ট হ্যাশিং (Consistent Hashing) <a class="header-anchor" href="#৩-কনসিস্টেন্ট-হ্যাশিং-consistent-hashing" aria-label="Permalink to &quot;৩. কনসিস্টেন্ট হ্যাশিং (Consistent Hashing)&quot;">​</a></h2><p><strong>থিওরি:</strong> যখন একাধিক সার্ভারে ডেটা ডিস্ট্রিবিউট করা হয় এবং হঠাৎ কোনো সার্ভার যুক্ত বা রিমুভ হয়, তখন রি-হ্যাশিংয়ের পরিমাণ কমানোর পদ্ধতিই হলো কনসিস্টেন্ট হ্যাশিং।</p><p><strong>প্রশ্ন:</strong> কেন সাধারণ হ্যাশিংয়ের পরিবর্তে কনসিস্টেন্ট হ্যাশিং ব্যবহার করা হয়? <strong>উত্তর:</strong> সাধারণ হ্যাশিংয়ে (key % n) যদি সার্ভার সংখ্যা (n) পরিবর্তন হয়, তবে প্রায় সব ডেটা মুভ করতে হয়। কিন্তু কনসিস্টেন্ট হ্যাশিংয়ে গড়ে মাত্র <code>k/n</code> সংখ্যক ডেটা মুভ করতে হয়, যা ক্যাশ এবং ডাটাবেস স্কেলিংয়ের জন্য অত্যন্ত কার্যকর।</p><hr><h2 id="৪-ল্যাটেন্সি-বনাম-থ্রুপুট-latency-vs-throughput" tabindex="-1">৪. ল্যাটেন্সি বনাম থ্রুপুট (Latency vs Throughput) <a class="header-anchor" href="#৪-ল্যাটেন্সি-বনাম-থ্রুপুট-latency-vs-throughput" aria-label="Permalink to &quot;৪. ল্যাটেন্সি বনাম থ্রুপুট (Latency vs Throughput)&quot;">​</a></h2><ul><li><strong>Latency:</strong> একটি রিকোয়েস্ট শুরু থেকে শেষ হতে মোট কত সময় লাগে (Time)। উদা: ১০০ মিলিসেকেন্ড।</li><li><strong>Throughput:</strong> একটি নির্দিষ্ট সময়ে সিস্টেম কতগুলো রিকোয়েস্ট প্রসেস করতে পারে (Volume)। উদা: ৫০০ রিকোয়েস্ট প্রতি সেকেন্ড।</li></ul><p><strong>টিপ:</strong> সবসময় চেষ্টা করা হয় ল্যাটেন্সি কমাতে এবং থ্রুপুট বাড়াতে।</p><hr><h2 id="৫-সিঙ্গেল-পয়েন্ট-অফ-ফেইলিওর-spof" tabindex="-1">৫. সিঙ্গেল পয়েন্ট অফ ফেইলিওর (SPOF) <a class="header-anchor" href="#৫-সিঙ্গেল-পয়েন্ট-অফ-ফেইলিওর-spof" aria-label="Permalink to &quot;৫. সিঙ্গেল পয়েন্ট অফ ফেইলিওর (SPOF)&quot;">​</a></h2><p><strong>থিওরি:</strong> সিস্টেমের এমন একটি কম্পোনেন্ট যা ফেইল করলে পুরো সিস্টেম বন্ধ হয়ে যায়।</p><p><strong>প্রশ্ন:</strong> কীভাবে আপনি SPOF দূর করবেন? <strong>উত্তর:</strong> Redundancy ব্যবহারের মাধ্যমে। প্রতিটি কম্পোনেন্টের (Load balancer, Database, Server) অন্তত একটি ব্যাকআপ বা ডুপ্লিকেট রাখতে হবে যাতে একটি ফেইল করলেও অন্যটি কাজ চালিয়ে নিতে পারে।</p><h2 id="৬-সিনারিও-ভিত্তিক-প্রশ্ন-scenario-based-questions" tabindex="-1">৬. সিনারিও ভিত্তিক প্রশ্ন (Scenario-based Questions) <a class="header-anchor" href="#৬-সিনারিও-ভিত্তিক-প্রশ্ন-scenario-based-questions" aria-label="Permalink to &quot;৬. সিনারিও ভিত্তিক প্রশ্ন (Scenario-based Questions)&quot;">​</a></h2><p>ইন্টারভিউতে আপনাকে কিছু বাস্তব পরিস্থিতি দেওয়া হতে পারে। নিচে এমন কিছু কমন সিনারিও দেওয়া হলো:</p><h3 id="সিনারিও-১-আপনার-সিস্টেমে-হঠাৎ-ট্রাফিক-১০-গুণ-বেড়ে-গেছে-কিন্তু-আপনার-ডাটাবেস-স্লো-হয়ে-গেছে।-আপনি-কী-করবেন" tabindex="-1">সিনারিও ১: &quot;আপনার সিস্টেমে হঠাৎ ট্রাফিক ১০ গুণ বেড়ে গেছে, কিন্তু আপনার ডাটাবেস স্লো হয়ে গেছে। আপনি কী করবেন?&quot; <a class="header-anchor" href="#সিনারিও-১-আপনার-সিস্টেমে-হঠাৎ-ট্রাফিক-১০-গুণ-বেড়ে-গেছে-কিন্তু-আপনার-ডাটাবেস-স্লো-হয়ে-গেছে।-আপনি-কী-করবেন" aria-label="Permalink to &quot;সিনারিও ১: &quot;আপনার সিস্টেমে হঠাৎ ট্রাফিক ১০ গুণ বেড়ে গেছে, কিন্তু আপনার ডাটাবেস স্লো হয়ে গেছে। আপনি কী করবেন?&quot;&quot;">​</a></h3><p><strong>সমাধান:</strong> ১. <strong>Caching:</strong> প্রথমে চেক করব পপুলার কুয়েরিগুলো Redis বা Memcached দিয়ে ক্যাশ করা যায় কি না। ২. <strong>Read Replicas:</strong> ডাটাবেসে অনেক বেশি রিড রিকোয়েস্ট থাকলে Read Replicas তৈরি করব। ৩. <strong>Database Sharding:</strong> যদি একটি ডাটাবেস আর লোড নিতে না পারে, তবে ডেটা ভিন্ন ভিন্ন সার্ভারে ভাগ (Shard) করে দেব। ৪. <strong>Indexing:</strong> ডাটাবেস কুয়েরিগুলো অপ্টিমাইজড কি না এবং ইনডেক্সিং ঠিক আছে কি না তা চেক করব।</p><h3 id="সিনারিও-২-ফেসবুকের-মতো-একটি-নিউজফিড-সিস্টেমে-আপনি-কনসিস্টেন্সি-নাকি-এভেইল্যাবিলিটি-বেছে-নেবেন" tabindex="-1">সিনারিও ২: &quot;ফেসবুকের মতো একটি নিউজফিড সিস্টেমে আপনি কনসিস্টেন্সি নাকি এভেইল্যাবিলিটি বেছে নেবেন?&quot; <a class="header-anchor" href="#সিনারিও-২-ফেসবুকের-মতো-একটি-নিউজফিড-সিস্টেমে-আপনি-কনসিস্টেন্সি-নাকি-এভেইল্যাবিলিটি-বেছে-নেবেন" aria-label="Permalink to &quot;সিনারিও ২: &quot;ফেসবুকের মতো একটি নিউজফিড সিস্টেমে আপনি কনসিস্টেন্সি নাকি এভেইল্যাবিলিটি বেছে নেবেন?&quot;&quot;">​</a></h3><p><strong>সমাধান:</strong> নিউজফিডের ক্ষেত্রে <strong>Availability (AP)</strong> বেশি গুরুত্বপূর্ণ। যদি এক বন্ধুর পোস্ট অন্য বন্ধু ২-৩ সেকেন্ড পরে দেখে, তাতে খুব বড় সমস্যা হবে না (Eventual Consistency)। কিন্তু ইউজার যদি নিউজফিড রিফ্রেশ করে এরর কার্ড দেখে, তবে ইউজার এক্সপেরিয়েন্স খারাপ হবে। তাই এখানে <strong>Eventual Consistency</strong> বেছে নেওয়া সঠিক সিদ্ধান্ত।</p><h3 id="সিনারিও-৩-একটি-ই-কমার্স-ফ্ল্যাশ-সেলের-সময়-কীভাবে-ইনভেন্টরি-ওভার-সেলিং-over-selling-ঠেকাবেন" tabindex="-1">সিনারিও ৩: &quot;একটি ই-কমার্স ফ্ল্যাশ সেলের সময় কীভাবে ইনভেন্টরি ওভার-সেলিং (Over-selling) ঠেকাবেন?&quot; <a class="header-anchor" href="#সিনারিও-৩-একটি-ই-কমার্স-ফ্ল্যাশ-সেলের-সময়-কীভাবে-ইনভেন্টরি-ওভার-সেলিং-over-selling-ঠেকাবেন" aria-label="Permalink to &quot;সিনারিও ৩: &quot;একটি ই-কমার্স ফ্ল্যাশ সেলের সময় কীভাবে ইনভেন্টরি ওভার-সেলিং (Over-selling) ঠেকাবেন?&quot;&quot;">​</a></h3><p><strong>সমাধান:</strong> ১. <strong>Distributed Locking:</strong> Redis বা অন্য কোনো পদ্ধতিতে ইনভেন্টরি স্টকের ওপর লক ব্যবহার করব যাতে দুইজন ইউজার একই সাথে শেষ আইটেমটি কিনতে না পারে। ২. <strong>Optimistic Locking:</strong> ডাটাবেস লেভেলে ভার্সন চেক করে আপডেট করব। ৩. <strong>Queueing:</strong> অতিরিক্ত রিকোয়েস্টগুলো মেসেজ কিউতে রেখে প্রসেস করব যাতে মেইন ডাটাবেসে রিকোয়েস্ট লিমিটেড থাকে।</p><hr><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>ইন্টারভিউয়ার আপনার কাছ থেকে শুধু পড়াশোনা করা উত্তর চান না, তিনি দেখতে চান আপনি বাস্তব জীবনে কীভাবে ডিজাইন ডিসিশন নেন। তাই প্রতিটি কনসেপ্টের ট্রেড-অফগুলো মাথায় রাখুন।</p></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/interview/core-concepts.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const coreConcepts = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  coreConcepts as default
};
