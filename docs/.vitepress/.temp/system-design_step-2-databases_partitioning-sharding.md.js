import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Data Partitioning & Sharding","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-2-databases/partitioning-sharding.md","filePath":"system-design/step-2-databases/partitioning-sharding.md"}');
const _sfc_main = { name: "system-design/step-2-databases/partitioning-sharding.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="data-partitioning-sharding" tabindex="-1">Data Partitioning &amp; Sharding <a class="header-anchor" href="#data-partitioning-sharding" aria-label="Permalink to &quot;Data Partitioning &amp; Sharding&quot;">​</a></h1><p>যখন আপনার ডেটাবেসের সাইজ এবং ট্রাফিক একটি সিঙ্গেল সার্ভারের ধারণক্ষমতা ছাড়িয়ে যায়, তখন &#39;Partitioning&#39; এবং &#39;Sharding&#39; ই একমাত্র সমাধান।</p><h2 id="১-data-partitioning-পার্টিশনিং" tabindex="-1">১. Data Partitioning (পার্টিশনিং) <a class="header-anchor" href="#১-data-partitioning-পার্টিশনিং" aria-label="Permalink to &quot;১. Data Partitioning (পার্টিশনিং)&quot;">​</a></h2><p>পার্টিশনিং হলো একটি বড় ডেটাবেস টেবিলকে ছোট ছোট লজিক্যাল অংশে ভাগ করা। এটি মূলত একটি সার্ভারের মধ্যেই মেমোরি বা স্টোরেজ ভালোমতো ম্যানেজ করার জন্য করা হয়।</p><h3 id="প্রকারভেদ" tabindex="-1">প্রকারভেদ: <a class="header-anchor" href="#প্রকারভেদ" aria-label="Permalink to &quot;প্রকারভেদ:&quot;">​</a></h3><ul><li><strong>Vertical Partitioning:</strong> টেবিলের কলামগুলোকে আলাদা করা। (যেমন: ইউজারের প্রোফাইল ফটো একটি আলাদা টেবিলে রাখা আর নাম-ইমেইল অন্য টেবিলে)।</li><li><strong>Horizontal Partitioning:</strong> টেবিলের রোগুলোকে (Rows) আলাদা করা। (যেমন: ১ থেকে ১০০ ইউজার এক জায়গায়, ১০১ থেকে ২০০ ইউজার অন্য জায়গায়)।</li></ul><h2 id="২-database-sharding-শার্ডিং" tabindex="-1">২. Database Sharding (শার্ডিং) <a class="header-anchor" href="#২-database-sharding-শার্ডিং" aria-label="Permalink to &quot;২. Database Sharding (শার্ডিং)&quot;">​</a></h2><p>শার্ডিং হলো হরাইজন্টাল পার্টিশনিং এর একটি অ্যাডভান্সড রূপ, যেখানে ডেটা বিভিন্ন সার্ভারে ভাগ করে দেওয়া হয়। শার্ডিং এর ফলে প্রতিটি সার্ভার স্বাধীনভাবে কাজ করতে পারে।</p><h3 id="শার্ডিং-কিভাবে-কাজ-করে-sharding-key" tabindex="-1">শার্ডিং কিভাবে কাজ করে? (Sharding Key) <a class="header-anchor" href="#শার্ডিং-কিভাবে-কাজ-করে-sharding-key" aria-label="Permalink to &quot;শার্ডিং কিভাবে কাজ করে? (Sharding Key)&quot;">​</a></h3><p>ডেটাকে কিভাবে ভাগ করা হবে তা একটি &#39;Shard Key&#39; এর ওপর নির্ভর করে।</p><ul><li><strong>Range-based:</strong> ইউজারের আইডির রেঞ্জ অনুযায়ী ভাগ করা (যেমন: এশিয়া রিজিয়ন এর ইউজার এক সার্ভারে, আমেরিকা অন্য সার্ভারে)।</li><li><strong>Hash-based:</strong> ইউজারের আইডিকে হ্যাশ ফাংশনে পাঠিয়ে পাওয়া ভ্যালু অনুযায়ী সার্ভার সিলেক্ট করা। এতে ডেটা সমানভাবে ডিস্ট্রিবিউটেড থাকে।</li></ul><h2 id="৩-শার্ডিং-এর-চ্যালেঞ্জসমূহ" tabindex="-1">৩. শার্ডিং এর চ্যালেঞ্জসমূহ <a class="header-anchor" href="#৩-শার্ডিং-এর-চ্যালেঞ্জসমূহ" aria-label="Permalink to &quot;৩. শার্ডিং এর চ্যালেঞ্জসমূহ&quot;">​</a></h2><ul><li><strong>Complexity:</strong> অ্যাপ্লিকেশন কোডকে জানতে হবে কোন ডেটা কোন শার্ডে (সার্ভারে) আছে। এর জন্য একটি &#39;Routing Layer&#39; প্রয়োজন হতে পারে।</li><li><strong>Joins across Shards:</strong> বিভিন্ন শার্ড বা সার্ভারের মধ্যে জয়েন (Join) অপারেশন চালানো অসম্ভব বা অত্যন্ত সময়সাপেক্ষ।</li><li><strong>Rebalancing:</strong> যদি কোনো শার্ড একদম পূর্ণ হয়ে যায়, তবে ডেটা নতুন করে ভাগ করা (Resharding) বেশ কঠিন কাজ।</li></ul><h2 id="পার্থক্য-একনজরে" tabindex="-1">পার্থক্য একনজরে <a class="header-anchor" href="#পার্থক্য-একনজরে" aria-label="Permalink to &quot;পার্থক্য একনজরে&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="${ssrRenderStyle({ "text-align": "left" })}">তুলনা</th><th style="${ssrRenderStyle({ "text-align": "left" })}">Partitioning</th><th style="${ssrRenderStyle({ "text-align": "left" })}">Sharding</th></tr></thead><tbody><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>অবস্থান</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">একটি সিঙ্গেল সার্ভারে হতে পারে</td><td style="${ssrRenderStyle({ "text-align": "left" })}">অবশ্যই একাধিক ডিস্ট্রিবিউটেড সার্ভারে</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>উদ্দেশ্য</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">ডেটা ম্যানেজমেন্ট সহজ করা</td><td style="${ssrRenderStyle({ "text-align": "left" })}">স্কেলেবিলিটি ও পারফরম্যান্স বাড়ানো</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>নির্ভরতা</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">মেইন ডিবি সার্ভারের ওপর নির্ভর</td><td style="${ssrRenderStyle({ "text-align": "left" })}">প্রতিটি শার্ড স্বাধীন</td></tr></tbody></table><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>বড় সিস্টেমের ক্ষেত্রে <strong>Sharding</strong> হলো শেষ আশ্রয়। শার্ডিং করার আগে অবশ্যই ইনডেক্সিং এবং ক্যাশিং অপটিমাইজ করা উচিত, কারণ শার্ডিং সিস্টেমের জটিলতা বহুগুণ বাড়িয়ে দেয়।</p></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-2-databases/partitioning-sharding.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const partitioningSharding = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  partitioningSharding as default
};
