import { ssrRenderAttrs, ssrRenderAttr, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const _imports_0 = "/dev-guides/assets/twitter-architecture.DNBS1KQf.png";
const _imports_1 = "/dev-guides/assets/twitter-db-schema.y0nn78GW.png";
const __pageData = JSON.parse('{"title":"Designing Twitter / X (Newsfeed System)","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-12-practice/twitter.md","filePath":"system-design/step-12-practice/twitter.md"}');
const _sfc_main = { name: "system-design/step-12-practice/twitter.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="designing-twitter-x-newsfeed-system" tabindex="-1">Designing Twitter / X (Newsfeed System) <a class="header-anchor" href="#designing-twitter-x-newsfeed-system" aria-label="Permalink to &quot;Designing Twitter / X (Newsfeed System)&quot;">​</a></h1><p>&quot;Twitter&quot; বা &quot;Facebook Newsfeed&quot; ডিজাইন করা একটি অত্যন্ত জনপ্রিয় ইন্টারভিউ প্রশ্ন। এটি একটি <strong>Read-Heavy</strong> সিস্টেম, যেখানে ডেটা কনসিস্টেন্সির চেয়ে <strong>Availability</strong> এবং <strong>Low Latency</strong> বেশি গুরুত্বপূর্ণ।</p><p>এই গাইডে আমরা দেখব কিভাবে মিলিয়ন ইউজারের জন্য একটি রিয়েল-টাইম নিউজফিড সিস্টেম ডিজাইন করা যায়।</p><h2 id="_1-requirements-রিকয়রমেন্টস" tabindex="-1">1. Requirements (রিকয়রমেন্টস) <a class="header-anchor" href="#_1-requirements-রিকয়রমেন্টস" aria-label="Permalink to &quot;1. Requirements (রিকয়রমেন্টস)&quot;">​</a></h2><h3 id="functional-requirements-ফিচারস" tabindex="-1">Functional Requirements (ফিচারস) <a class="header-anchor" href="#functional-requirements-ফিচারস" aria-label="Permalink to &quot;Functional Requirements (ফিচারস)&quot;">​</a></h3><ol><li><strong>Post Tweet:</strong> ইউজাররা টুইট (টেক্সট, ইমেজ, ভিডিও) পোস্ট করতে পারবে।</li><li><strong>Timeline (Newsfeed):</strong> ইউজার তার ফলো করা মানুষদের টুইটগুলো ক্রমানুসারে (Reverse Chronological Order) দেখতে পাবে।</li><li><strong>Follow/Unfollow:</strong> ইউজাররা একে অপরকে ফলো করতে পারবে।</li><li><strong>Search:</strong> কি-ওয়ার্ড দিয়ে টুইট সার্চ করা যাবে।</li></ol><h3 id="non-functional-requirements-কোয়ালিটি" tabindex="-1">Non-Functional Requirements (কোয়ালিটি) <a class="header-anchor" href="#non-functional-requirements-কোয়ালিটি" aria-label="Permalink to &quot;Non-Functional Requirements (কোয়ালিটি)&quot;">​</a></h3><ol><li><strong>High Availability:</strong> সিস্টেম সবসময় চালু থাকতে হবে (CAP থিওরামের AP)।</li><li><strong>Low Latency (200ms):</strong> নিউজফিড লোড হতে ২০মিলিসেকেন্ডের বেশি নেয়া যাবে না।</li><li><strong>Eventual Consistency:</strong> আমি টুইট করার সাথে সাথেই আমার সব ফলোয়ারের কাছে সেটি না পৌঁছালেও সমস্যা নেই, কয়েক সেকেন্ড দেরি হতে পারে।</li></ol><hr><h2 id="_2-capacity-estimation-ক্যাপাসিটি-এস্টিমেশন" tabindex="-1">2. Capacity Estimation (ক্যাপাসিটি এস্টিমেশন) <a class="header-anchor" href="#_2-capacity-estimation-ক্যাপাসিটি-এস্টিমেশন" aria-label="Permalink to &quot;2. Capacity Estimation (ক্যাপাসিটি এস্টিমেশন)&quot;">​</a></h2><p>Twitter একটি <strong>Read-Heavy</strong> সিস্টেম। অর্থাৎ, টুইট পোস্ট করার চেয়ে টুইট পড়ার সংখ্যা অনেক বেশি।</p><ul><li><strong>Total Users:</strong> 1 Billion.</li><li><strong>Daily Active Users (DAU):</strong> 200 Million.</li><li><strong>Writes (Post Tweet):</strong> 100 Million tweets / day.</li><li><strong>Reads (View Timeline):</strong> 20 Billion views / day.</li><li><strong>Read:Write Ratio:</strong> 200:1 (প্রচুর রিড হয়)।</li></ul><h3 id="storage-estimation" tabindex="-1">Storage Estimation <a class="header-anchor" href="#storage-estimation" aria-label="Permalink to &quot;Storage Estimation&quot;">​</a></h3><ul><li>মনে করি প্রতিটি টুইট ১৪০ ক্যারেক্টার এবং কিছু মেটাডেটা সহ <strong>500 bytes</strong>।</li><li>Daily Storage = 100M * 500 bytes = <strong>50 GB / day</strong>।</li><li>5 Years Storage = 50 GB _ 365 _ 5 ≈ <strong>90 TB</strong> (মিডিয়া ফাইল ছাড়া)।</li></ul><hr><h2 id="_3-high-level-design-hld" tabindex="-1">3. High-Level Design (HLD) <a class="header-anchor" href="#_3-high-level-design-hld" aria-label="Permalink to &quot;3. High-Level Design (HLD)&quot;">​</a></h2><p>নিচে টুইটারের একটি হাই-লেভেল আর্কিটেকচার দেওয়া হলো:</p><p><img${ssrRenderAttr("src", _imports_0)} alt="Twitter System Architecture"></p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">flowchart TD</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    User[Clients (Mobile/Web)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    LB[Load Balancer]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    API[API Gateway]</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    subgraph Services</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        UserService[User Service (Profile/Graph)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        TweetService[Tweet Service (Post/Store)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        FanoutService[Fanout Service (Newsfeed)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        SearchService[Search Service]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    end</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    subgraph Storage</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        UserDB[(User DB - MySQL)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        TweetDB[(Tweet DB - Cassandra/MySQL)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        FollowDB[(Graph DB - Neo4j)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        Cache[(Redis Cluster)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    end</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    User --&gt;|HTTPS| LB</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    LB --&gt; API</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    API --&gt; UserService</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    API --&gt; TweetService</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    API --&gt; SearchService</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    API --&gt; FanoutService</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    UserService --&gt; UserDB</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    UserService --&gt; FollowDB</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    TweetService --&gt; TweetDB</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    FanoutService --&gt; Cache</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    SearchService --&gt; TweetDB</span></span></code></pre></div><hr><h2 id="_4-deep-dive-timeline-generation-fanout-service" tabindex="-1">4. Deep Dive: Timeline Generation (Fanout Service) <a class="header-anchor" href="#_4-deep-dive-timeline-generation-fanout-service" aria-label="Permalink to &quot;4. Deep Dive: Timeline Generation (Fanout Service)&quot;">​</a></h2><p>টুইটারের ডিজাইনের সবচেয়ে চ্যালেঞ্জিং পার্ট হলো <strong>নিউজফিড জেনারেশন</strong>। যখন একজন ইউজার টুইট করে, তখন তার সব ফলোয়ারের ফিডে সেই টুইটটি পৌঁছে দিতে হয়। একে বলা হয় <strong>Fanout</strong>।</p><h3 id="approach-1-pull-model-fanout-on-load" tabindex="-1">Approach 1: Pull Model (Fanout on Load) <a class="header-anchor" href="#approach-1-pull-model-fanout-on-load" aria-label="Permalink to &quot;Approach 1: Pull Model (Fanout on Load)&quot;">​</a></h3><p>যখন ইউজার অ্যাপ ওপেন করে (Timeline রিফ্রেশ করে), তখন সিস্টেম:</p><ol><li>ইউজার যাদের ফলো করে তাদের তালিকা বের করে।</li><li>সেই ফলোয়িং-লিস্টের সবার লেটেস্ট টুইটগুলো কুয়েরি করে নিয়ে আসে।</li><li>মেমোরিতে মার্জ (Merge) করে টাইমলাইন দেখায়।</li></ol><p><strong>সমস্যা:</strong> যখন ফলোয়িং সংখ্যা অনেক বেশি হয়, তখন এই কুয়েরি খুব স্লো হয়ে যায়।</p><h3 id="approach-2-push-model-fanout-on-write-preferred" tabindex="-1">Approach 2: Push Model (Fanout on Write) - <strong>Preferred</strong> <a class="header-anchor" href="#approach-2-push-model-fanout-on-write-preferred" aria-label="Permalink to &quot;Approach 2: Push Model (Fanout on Write) - **Preferred**&quot;">​</a></h3><p>যখন কেউ টুইট <strong>পোস্ট</strong> করে, তখনই সিস্টেম তার সব ফলোয়ারের প্রি-কম্পিউটেড টাইমলাইন লিস্টে (Redis List) টুইটটি ইনসার্ট করে দেয়।</p><ol><li>Alice টুইট করল।</li><li>Fanout Service এলিসের সব ফলোয়ারকে খুঁজে বের করে।</li><li>সবার <code>HomeTimeline</code> (Redis) এ টুইট আইডিটি পুশ করে দেয়।</li><li>Bob যখন লগইন করে, সে সরাসরি Redis থেকে তার টাইমলাইন পেয়ে যায় (0 latency)।</li></ol><p><strong>সমস্যা (The Justin Bieber Problem):</strong> জাস্টিন বিবারের মতো সেলেব্রিটির ফলোয়ার মিলিয়ন মিলিয়ন। একবার টুইট করলেই কোটি কোটি মানুষের ক্যাশ আপডেট করতে গেলে সিস্টেম বসে যাবে।</p><h3 id="approach-3-hybrid-model-twitter-s-solution" tabindex="-1">Approach 3: Hybrid Model (Twitter&#39;s Solution) <a class="header-anchor" href="#approach-3-hybrid-model-twitter-s-solution" aria-label="Permalink to &quot;Approach 3: Hybrid Model (Twitter&#39;s Solution)&quot;">​</a></h3><ul><li><strong>সাধারণ ইউজারদের জন্য:</strong> <strong>Push Model</strong> ব্যবহার করা হয়।</li><li><strong>সেলেব্রিটিদের জন্য:</strong> <strong>Pull Model</strong> ব্যবহার করা হয়। তাদের টুইট ফলোয়ারদের টাইমলাইনে পুশ করা হয় না। যখন ইউজার ফিড লোড করে, তখন সাধারণ টুইটগুলোর সাথে সেলেব্রিটিদের টুইট মার্জ করে দেখানো হয়।</li></ul><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">flowchart LR</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    User[User Posts Tweet] --&gt; LB</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    LB --&gt; TweetService</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    TweetService --&gt;|1. Store Tweet| DB[(Tweet DB)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    TweetService --&gt;|2. Trigger| Fanout[Fanout Service]</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    Fanout --&gt;|3. Get Followers| UserGraph[(Follower Graph)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    Fanout --&gt;|4. Push to Timeline| Redis[(Redis Timeline Cache)]</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    Viewer[Viewer Refreshes Feed] --&gt;|5. Get Feed| Redis</span></span></code></pre></div><hr><h2 id="_5-deep-dive-search-service-earlybird" tabindex="-1">5. Deep Dive: Search Service (Earlybird) <a class="header-anchor" href="#_5-deep-dive-search-service-earlybird" aria-label="Permalink to &quot;5. Deep Dive: Search Service (Earlybird)&quot;">​</a></h2><p>টুইটারের সার্চ সিস্টেম রিয়েল-টাইমে কাজ করে। টুইট করার কয়েক সেকেন্ডের মধ্যেই সেটি সার্চেবল হতে হয়। টুইটার এর জন্য <strong>Earlybird</strong> নামক একটি মডিফাইড <strong>Lucene</strong> বেসড ইঞ্জিন ব্যবহার করে।</p><h3 id="ইনডেক্সিং-ফ্লো" tabindex="-1">ইনডেক্সিং ফ্লো: <a class="header-anchor" href="#ইনডেক্সিং-ফ্লো" aria-label="Permalink to &quot;ইনডেক্সিং ফ্লো:&quot;">​</a></h3><ol><li><strong>Ingestion:</strong> টুইট পোস্ট হওয়ার সাথে সাথে এটি Kafka-তে চলে যায়।</li><li><strong>Processing:</strong> একটি ইনজেস্টর সার্ভিস টুইটটিকে টোকেনাইজ করে এবং হ্যাশট্যাগ এক্সট্র্যাক্ট করে।</li><li><strong>Indexing:</strong> প্রসেস করা টুইটটি <strong>Earlybird</strong> শার্ডে স্টোর হয়। প্রতিটি শার্ড একটি নির্দিষ্ট সময়ের (যেমন ১ ঘন্টা বা ১ দিন) টুইট ধারণ করে।</li></ol><h3 id="সার্চ-ফ্লো-scatter-gather" tabindex="-1">সার্চ ফ্লো (Scatter-Gather): <a class="header-anchor" href="#সার্চ-ফ্লো-scatter-gather" aria-label="Permalink to &quot;সার্চ ফ্লো (Scatter-Gather):&quot;">​</a></h3><ol><li>ইউজার &#39;Cristiano&#39; লিখে সার্চ দিল।</li><li><strong>Blender (Aggregator)</strong> সার্ভিস এই রিকোয়েস্টটি রিসিভ করে।</li><li>এটি প্যারালালি সব Earlybird শার্ডে সার্চ রিকোয়েস্ট পাঠায় (<strong>Scatter</strong>)।</li><li>প্রতিটি শার্ড রেজাল্ট রিটার্ন করে।</li><li>Blender সব রেজাল্ট মার্জ করে, সর্ট করে এবং ইউজারের কাছে পাঠায় (<strong>Gather</strong>)।</li></ol><hr><h2 id="_6-database-schema-design" tabindex="-1">6. Database Schema Design <a class="header-anchor" href="#_6-database-schema-design" aria-label="Permalink to &quot;6. Database Schema Design&quot;">​</a></h2><h3 id="sql-vs-nosql" tabindex="-1">SQL vs NoSQL? <a class="header-anchor" href="#sql-vs-nosql" aria-label="Permalink to &quot;SQL vs NoSQL?&quot;">​</a></h3><ul><li><strong>User Profile:</strong> রিলেশনাল ডেটা, তাই <strong>MySQL</strong>।</li><li><strong>Tweets:</strong> প্রচুর রাইট এবং রিড, রিলেশন কম। <strong>Cassandra</strong> (Wide-column store) এর জন্য সেরা। টুইটারের নিজস্ব ভার্সন হলো <strong>Manhattan</strong>।</li><li><strong>Social Graph (Followers):</strong> কে কাকে ফলো করছে, এটি গ্রাফ ডেটা। <strong>Neo4j</strong> বা <strong>MySQ</strong> (Adjacency List) দিয়ে ম্যানেজ করা যায়।</li></ul><h3 id="visual-schema-design" tabindex="-1">Visual Schema Design <a class="header-anchor" href="#visual-schema-design" aria-label="Permalink to &quot;Visual Schema Design&quot;">​</a></h3><p>নিচে এন্টিটি রিলেশনশিপ ডায়াগ্রামের একটি উদাহরণ দেওয়া হলো:</p><p><img${ssrRenderAttr("src", _imports_1)} alt="Twitter Database Schema"></p><hr><h2 id="_7-scalability-optimization" tabindex="-1">7. Scalability &amp; Optimization <a class="header-anchor" href="#_7-scalability-optimization" aria-label="Permalink to &quot;7. Scalability &amp; Optimization&quot;">​</a></h2><ol><li><p><strong>Sharding:</strong></p><ul><li><strong>Sharding by UserID:</strong> একজন ইউজারের সব টুইট একই শার্ডে থাকবে। কিন্তু হট ইউজার (সেলিব্রিটি) সমস্যা করতে পারে।</li><li><strong>Sharding by TweetID (Snowflake ID):</strong> টুইটার <strong>Snowflake</strong> অ্যালগরিদম ব্যবহার করে ইউনিক আইডি জেনারেট করে যা সময়ের সাথে সর্ট করা যায় (Time-sortable)। এটি বেস্ট অ্যাপ্রোচ।</li></ul></li><li><p><strong>Caching:</strong></p><ul><li><strong>Redis</strong> ব্যবহার করা হয় প্রতিটি ইউজারের <code>HomeTimeline</code> স্টোর করার জন্য। একটি <code>List</code> ডাটা স্ট্রাকচারে শুধু <code>TweetID</code> গুলো রাখা হয়।</li><li>মেমোরি বাঁচাতে শুধু লাস্ট ৮০০ টুইট ক্যাশে রাখা হয়।</li></ul></li></ol><hr><h2 id="_8-summary" tabindex="-1">8. Summary <a class="header-anchor" href="#_8-summary" aria-label="Permalink to &quot;8. Summary&quot;">​</a></h2><ul><li><strong>Write Path:</strong> User -&gt; LB -&gt; Tweet Service -&gt; DB + Fanout Service -&gt; Redis.</li><li><strong>Read Path:</strong> User -&gt; LB -&gt; Timeline Service -&gt; Redis (Hybrid Merge) -&gt; Return Feed.</li><li><strong>Optimization:</strong> Hybrid Fanout (Push for normal, Pull for celebrities).</li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-12-practice/twitter.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const twitter = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  twitter as default
};
