import { ssrRenderAttrs, ssrRenderAttr, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const _imports_0 = "/dev-guides/assets/whatsapp-architecture.0G1WXl7r.png";
const _imports_1 = "/dev-guides/assets/whatsapp-db-schema.BGFaF7Gb.png";
const __pageData = JSON.parse('{"title":"Designing WhatsApp (Real-time Chat)","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-12-practice/whatsapp.md","filePath":"system-design/step-12-practice/whatsapp.md"}');
const _sfc_main = { name: "system-design/step-12-practice/whatsapp.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="designing-whatsapp-real-time-chat" tabindex="-1">Designing WhatsApp (Real-time Chat) <a class="header-anchor" href="#designing-whatsapp-real-time-chat" aria-label="Permalink to &quot;Designing WhatsApp (Real-time Chat)&quot;">​</a></h1><p><strong>WhatsApp</strong> বা <strong>Facebook Messenger</strong> এর মতো সিস্টেম ডিজাইন করা হলো <strong>Real-time Communication</strong> সিস্টেম ডিজাইনের সেরা উদাহরণ। এখানে চ্যালেঞ্জ হলো বিলিয়ন ইউজারের মধ্যে খুব কম ল্যাটেন্সিতে ম্যাসেজ আদান-প্রদান করা।</p><h2 id="_1-requirements-রিকয়রমেন্টস" tabindex="-1">1. Requirements (রিকয়রমেন্টস) <a class="header-anchor" href="#_1-requirements-রিকয়রমেন্টস" aria-label="Permalink to &quot;1. Requirements (রিকয়রমেন্টস)&quot;">​</a></h2><h3 id="functional-requirements" tabindex="-1">Functional Requirements <a class="header-anchor" href="#functional-requirements" aria-label="Permalink to &quot;Functional Requirements&quot;">​</a></h3><ol><li><strong>1-on-1 Chat:</strong> দুইজন ইউজার রিয়েল-টাইমে ম্যাসেজ পাঠাতে পারবে।</li><li><strong>Group Chat:</strong> একাধিক ইউজার (২৫৬ বা ৫১২ জন) একসাথে চ্যাট করতে পারবে।</li><li><strong>Receipts:</strong> Sent (✔), Delivered (✔✔), Read (Blue ✔✔) একনলেজমেন্ট থাকতে হবে।</li><li><strong>Online/Last Seen Status:</strong> ইউজার অনলাইনে আছে কিনা তা দেখা যাবে।</li><li><strong>Media Sharing:</strong> ইমেজ, ভিডিও এবং ফাইল আদান-প্রদান।</li></ol><h3 id="non-functional-requirements" tabindex="-1">Non-Functional Requirements <a class="header-anchor" href="#non-functional-requirements" aria-label="Permalink to &quot;Non-Functional Requirements&quot;">​</a></h3><ol><li><strong>Low Latency:</strong> ম্যাসেজ পাঠানোর সাথে সাথেই ডেলিভার হতে হবে।</li><li><strong>High Availability:</strong> সিস্টেম ডাউন হওয়া চলবে না।</li><li><strong>Scale:</strong> ২ বিলিয়ন+ ইউজার হ্যান্ডেল করতে হবে।</li></ol><hr><h2 id="_2-capacity-estimation" tabindex="-1">2. Capacity Estimation <a class="header-anchor" href="#_2-capacity-estimation" aria-label="Permalink to &quot;2. Capacity Estimation&quot;">​</a></h2><ul><li><strong>Daily Active Users (DAU):</strong> 2 Billion.</li><li><strong>Messages per day:</strong> 100 Billion.</li><li><strong>Media Sharing:</strong> 10% messages contain media.</li></ul><h3 id="bandwidth-estimation" tabindex="-1">Bandwidth Estimation <a class="header-anchor" href="#bandwidth-estimation" aria-label="Permalink to &quot;Bandwidth Estimation&quot;">​</a></h3><ul><li>টেক্সট ম্যাসেজ খুব ছোট (100 Bytes)।</li><li>100 Billion * 100 Bytes = 10 TB / day text data.</li><li>মিডিয়া ফাইল অনেক বেশি ব্যান্ডউইথ নিবে।</li></ul><hr><h2 id="_3-high-level-design-hld" tabindex="-1">3. High-Level Design (HLD) <a class="header-anchor" href="#_3-high-level-design-hld" aria-label="Permalink to &quot;3. High-Level Design (HLD)&quot;">​</a></h2><p>টুইটার বা ইউটিউবের মতো HTTP Request/Response মডেল এখানে কাজ করবে না, কারণ HTTP তে সার্ভার ক্লায়েন্টকে নিজে থেকে পুশ করতে পারে না (Polling ছাড়া)। তাই আমরা <strong>WebSocket</strong> ব্যবহার করব।</p><h3 id="architecture-overview" tabindex="-1">Architecture Overview <a class="header-anchor" href="#architecture-overview" aria-label="Permalink to &quot;Architecture Overview&quot;">​</a></h3><p>নিচে একটি হাই-লেভেল আর্কিটেকচার ডায়াগ্রাম দেওয়া হলো:</p><p><img${ssrRenderAttr("src", _imports_0)} alt="WhatsApp Architecture"></p><div class="language-mermaid vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">mermaid</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">flowchart TD</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    UserA[User A]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    UserB[User B]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    LB[Load Balancer]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    WebSocket[WebSocket Gateway / Chat Server]</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    subgraph Services</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        AuthService[Auth Service]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        GroupService[Group Mgmt Service]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        PresenceService[Presence Service (Online Status)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        MediaService[Asset Service]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    end</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    subgraph Storage</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        Redis[(Redis - Presence &amp; Cache)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        HBase[(HBase/Cassandra - Chat History)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">        S3[(Object Storage - Media)]</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    end</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    UserA &lt;--&gt;|WebSocket Connection| LB</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    UserB &lt;--&gt;|WebSocket Connection| LB</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    LB &lt;--&gt; WebSocket</span></span>
<span class="line"></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    WebSocket --&gt; AuthService</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    WebSocket --&gt; Redis</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    WebSocket --&gt; HBase</span></span>
<span class="line"><span style="${ssrRenderStyle({ "--shiki-light": "#24292E", "--shiki-dark": "#E1E4E8" })}">    WebSocket --&gt; PresenceService</span></span></code></pre></div><h3 id="protocol-websocket-vs-http-polling" tabindex="-1">Protocol: WebSocket vs HTTP polling <a class="header-anchor" href="#protocol-websocket-vs-http-polling" aria-label="Permalink to &quot;Protocol: WebSocket vs HTTP polling&quot;">​</a></h3><ul><li><strong>HTTP Polling:</strong> ক্লায়েন্ট বারবার সার্ভারকে জিজ্ঞেস করে &quot;নতুন ম্যাসেজ আছে?&quot; (অদক্ষ)।</li><li><strong>Long Polling:</strong> সার্ভার রিকোয়েস্ট হোল্ড করে রাখে যতক্ষণ না নতুন ডেটা আসে।</li><li><strong>WebSocket (Best):</strong> সার্ভার এবং ক্লায়েন্টের মধ্যে একটি <strong>Persistent Connection</strong> তৈরি হয়। সার্ভার যেকোনো সময় ক্লায়েন্টকে ম্যাসেজ পুশ করতে পারে। WhatsApp ঠিক এটাই ব্যবহার করে।</li></ul><hr><h2 id="_4-deep-dive-message-delivery-flow" tabindex="-1">4. Deep Dive: Message Delivery Flow <a class="header-anchor" href="#_4-deep-dive-message-delivery-flow" aria-label="Permalink to &quot;4. Deep Dive: Message Delivery Flow&quot;">​</a></h2><h3 id="scenario-a-user-b-is-online" tabindex="-1">Scenario A: User B is Online <a class="header-anchor" href="#scenario-a-user-b-is-online" aria-label="Permalink to &quot;Scenario A: User B is Online&quot;">​</a></h3><ol><li><strong>User A</strong> চ্যাট সার্ভারে ম্যাসেজ পাঠায় (via WebSocket)।</li><li><strong>Chat Server</strong> দেখে User B কোন গেটওয়ে মেশিনে কানেক্টেড আছে (Redis এ ম্যাপিং থাকে)।</li><li>সার্ভার সরাসরি সেই কানেকশন দিয়ে User B কে ম্যাসেজ পুশ করে দেয়।</li></ol><h3 id="scenario-b-user-b-is-offline" tabindex="-1">Scenario B: User B is Offline <a class="header-anchor" href="#scenario-b-user-b-is-offline" aria-label="Permalink to &quot;Scenario B: User B is Offline&quot;">​</a></h3><ol><li><strong>User A</strong> ম্যাসেজ পাঠায়।</li><li><strong>Chat Server</strong> দেখে User B অফলাইন।</li><li>সার্ভার ম্যাসেজটি <strong>Database (HBase/Cassandra)</strong>-তে স্টোর করে রাখে।</li><li>User B যখন অনলাইন হয়, তখন সার্ভার পেন্ডিং সব ম্যাসেজ তাকে ডেলিভার করে দেয় (Store and Forward)।</li></ol><hr><h2 id="_5-deep-dive-end-to-end-encryption-e2ee" tabindex="-1">5. deep Dive: End-to-End Encryption (E2EE) <a class="header-anchor" href="#_5-deep-dive-end-to-end-encryption-e2ee" aria-label="Permalink to &quot;5. deep Dive: End-to-End Encryption (E2EE)&quot;">​</a></h2><p>WhatsApp এর অন্যতম ফিচার হলো E2EE। সার্ভার নিজেও ম্যাসেজ পড়তে পারে না। এটি <strong>Signal Protocol</strong> ব্যবহার করে কাজ করে।</p><ol><li>লগইন করার সময় প্রতিটি ইউজার <code>Public Key</code> এবং <code>Private Key</code> জেনারেট করে।</li><li><code>Public Key</code> সার্ভারে আপলোড করা থাকে।</li><li>User A যখন User B কে ম্যাসেজ পাঠায়, সে User B এর <code>Public Key</code> দিয়ে ম্যাসেজ এনক্রিপ্ট করে।</li><li>এই এনক্রিপ্ট করা ম্যাসেজ শুধু User B তার নিজের <code>Private Key</code> দিয়ে ডিক্রিপ্ট করতে পারে।</li></ol><hr><h2 id="_6-database-schema-design" tabindex="-1">6. Database Schema Design <a class="header-anchor" href="#_6-database-schema-design" aria-label="Permalink to &quot;6. Database Schema Design&quot;">​</a></h2><p>চ্যাট হিস্ট্রির জন্য আমাদের এমন ডেটাবেস দরকার যা প্রচুর রাইট (Write) হ্যান্ডেল করতে পারে।</p><ul><li><strong>MySQL?</strong> না, স্কেল করা কঠিন হবে ১০০ বিলিয়ন ম্যাসেজের জন্য।</li><li><strong>HBase / Cassandra:</strong> সেরা অপশন। এগুলো <strong>Wide-column</strong> স্টোর এবং Write-heavy অপারেশনের জন্য অপ্টিমাইজড। Facebook Messenger মূলত <strong>HBase</strong> ব্যবহার করে।</li></ul><h3 id="visual-schema-design" tabindex="-1">Visual Schema Design <a class="header-anchor" href="#visual-schema-design" aria-label="Permalink to &quot;Visual Schema Design&quot;">​</a></h3><p>নিচে এন্টিটি রিলেশনশিপ ডায়াগ্রামের একটি উদাহরণ দেওয়া হলো:</p><p><img${ssrRenderAttr("src", _imports_1)} alt="WhatsApp Database Schema"></p><hr><h2 id="_7-summary" tabindex="-1">7. Summary <a class="header-anchor" href="#_7-summary" aria-label="Permalink to &quot;7. Summary&quot;">​</a></h2><ul><li><strong>Protocol:</strong> WebSocket for low latency.</li><li><strong>Database:</strong> HBase/Cassandra for infinite chat history.</li><li><strong>Offline Handling:</strong> Store and Forward mechanism.</li><li><strong>Security:</strong> End-to-End Encryption using Signal Protocol.</li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-12-practice/whatsapp.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const whatsapp = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  whatsapp as default
};
