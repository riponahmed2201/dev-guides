import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Consistent Hashing","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-6-load-balancers/consistent-hashing.md","filePath":"system-design/step-6-load-balancers/consistent-hashing.md"}');
const _sfc_main = { name: "system-design/step-6-load-balancers/consistent-hashing.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="consistent-hashing" tabindex="-1">Consistent Hashing <a class="header-anchor" href="#consistent-hashing" aria-label="Permalink to &quot;Consistent Hashing&quot;">​</a></h1><p>ডিস্ট্রিবিউটেড সিস্টেম যখন অনেক বড় হয়ে যায় এবং অনেকগুলো ডেটাবেস বা ক্যাশ সার্ভার থাকে, তখন ডেটা কোন সার্ভারে যাবে তা ঠিক করার জন্য সাধারণ হ্যাশিং পর্যাপ্ত নয়। এখানেই <strong>Consistent Hashing</strong> এর প্রয়োজন পড়ে।</p><h2 id="_1-সাধারণ-হ্যাশিংয়ের-সমস্যা-modulo-hashing" tabindex="-1">1. সাধারণ হ্যাশিংয়ের সমস্যা (Modulo Hashing) <a class="header-anchor" href="#_1-সাধারণ-হ্যাশিংয়ের-সমস্যা-modulo-hashing" aria-label="Permalink to &quot;1. সাধারণ হ্যাশিংয়ের সমস্যা (Modulo Hashing)&quot;">​</a></h2><p>ধরা যাক আমাদের ৩টি সার্ভার আছে। কোনো ডেটা সেভ করার জন্য আমরা <code>hash(key) % 3</code> ব্যবহার করি।</p><ul><li>যদি একটি নতুন সার্ভার যোগ করা হয় (৩ থেকে ৪ হয়), তবে সব ডেটার লোকেশন বদলে যাবে (Modulo 4 হবে)।</li><li>এর ফলে ক্যাশ মিস (Cache Miss) হয় এবং প্রায় সব ডেটা নতুন করে সার্ভারগুলোর মধ্যে মুভ করতে হয়, যা হাই-ট্রাফিক সিস্টেমে বড় বিপর্যয় ঘটাতে পারে।</li></ul><h2 id="_2-consistent-hashing-কিভাবে-কাজ-করে" tabindex="-1">2. Consistent Hashing কিভাবে কাজ করে? <a class="header-anchor" href="#_2-consistent-hashing-কিভাবে-কাজ-করে" aria-label="Permalink to &quot;2. Consistent Hashing কিভাবে কাজ করে?&quot;">​</a></h2><p>এই পদ্ধতিতে হ্যাশ স্পেসকে একটি সার্কেল বা আংটির (Ring) মতো চিন্তা করা হয়।</p><ol><li><strong>সার্ভার ম্যাপিং:</strong> প্রথমে সার্ভারগুলোর আইপি বা নামকে হ্যাশ করে এই সার্কেলে বসানো হয়।</li><li><strong>ডেটা ম্যাপিং:</strong> ডেটা বা কী-কে (Key) হ্যাশ করে সার্কেলের ওপর বসানো হয়।</li><li><strong>অ্যাসাইনমেন্ট:</strong> সার্কেলের ওপর বসা ডেটা থেকে ঘড়ির কাঁটার দিকে (Clockwise) ঘুরলে সবার আগে যে সার্ভারটি পাওয়া যাবে, ডেটাটি সেই সার্ভারে সেভ হবে।</li></ol><h2 id="_3-সুবিধা-কি" tabindex="-1">3. সুবিধা কি? <a class="header-anchor" href="#_3-সুবিধা-কি" aria-label="Permalink to &quot;3. সুবিধা কি?&quot;">​</a></h2><ul><li><strong>কম ডেটা মুভমেন্ট:</strong> যদি একটি সার্ভার রিমুভ করা হয় বা নতুন যোগ করা হয়, তবে শুধুমাত্র সেই সার্ভারের কাছে থাকা বা তার পরবর্তী ডেটাগুলোই এফেক্টেড হয়। গড়ে মাত্র <code>1/n</code> অংশ ডেটা মুভ করতে হয়।</li><li><strong>Scalability:</strong> এটি সিস্টেমকে ডিনামিকালি স্কেল করতে সাহায্য করে কোনো বড় ডাউনটাইম ছাড়াই।</li></ul><h2 id="_4-virtual-nodes" tabindex="-1">4. Virtual Nodes <a class="header-anchor" href="#_4-virtual-nodes" aria-label="Permalink to &quot;4. Virtual Nodes&quot;">​</a></h2><p>সহজভাবে ভাগ করলে অনেক সময় একটি সার্ভারে বেশি এবং অন্যটিতে কম ডেটা পড়তে পারে। এটি সমাধান করার জন্য <strong>Virtual Nodes</strong> ব্যবহার করা হয়। একটি ফিজিক্যাল সার্ভারকে সার্কেলের বিভিন্ন জায়গায় রিপ্রেজেন্ট করা হয়, যাতে ডেটা ডিস্ট্রিবিউশন একদম সমান হয়।</p><hr><div class="important custom-block github-alert"><p class="custom-block-title">IMPORTANT</p><p>লোড ব্যালেন্সার এবং ডিস্ট্রিবিউটেড ডেটাবেস (যেমন: DynamoDB, Cassandra) এবং ক্যাশ সিস্টেমের (যেমন: Redis Cluster) মূলে কাজ করে এই <strong>Consistent Hashing</strong>। বড় স্কেলের সিস্টেম ডিজাইনে এটি একটি &#39;মাস্ট-নো&#39; (Must-know) কনসেপ্ট।</p></div></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-6-load-balancers/consistent-hashing.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const consistentHashing = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  consistentHashing as default
};
