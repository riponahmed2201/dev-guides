import { ssrRenderAttrs } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Performance Tradeoffs (পারফরম্যান্স ট্রেড-অফ)","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-11-tradeoffs/latency-tradeoffs.md","filePath":"system-design/step-11-tradeoffs/latency-tradeoffs.md"}');
const _sfc_main = { name: "system-design/step-11-tradeoffs/latency-tradeoffs.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="performance-tradeoffs-পারফরম্যান্স-ট্রেড-অফ" tabindex="-1">Performance Tradeoffs (পারফরম্যান্স ট্রেড-অফ) <a class="header-anchor" href="#performance-tradeoffs-পারফরম্যান্স-ট্রেড-অফ" aria-label="Permalink to &quot;Performance Tradeoffs (পারফরম্যান্স ট্রেড-অফ)&quot;">​</a></h1><p>সিস্টেম ডিজাইনে পারফরম্যান্স অপ্টিমাইজ করতে গেলে আমাদের প্রায়ই কিছু জিনিসের বিনিময়ে অন্য কিছু পেতে হয়। নিচে এমন তিনটি গুরুত্বপূর্ণ ট্রেড-অফ আলোচনা করা হলো।</p><h2 id="_1-memory-vs-latency-মেমোরি-বনাম-ল্যাটেন্সি" tabindex="-1">1. Memory vs Latency (মেমোরি বনাম ল্যাটেন্সি) <a class="header-anchor" href="#_1-memory-vs-latency-মেমোরি-বনাম-ল্যাটেন্সি" aria-label="Permalink to &quot;1. Memory vs Latency (মেমোরি বনাম ল্যাটেন্সি)&quot;">​</a></h2><p>আমরা মেমোরি (Space) খরচ করে ল্যাটেন্সি (Time) কমাতে পারি, অথবা ল্যাটেন্সি বাড়িয়ে মেমোরি বাঁচাতে পারি। একে <strong>Space-Time Tradeoff</strong>-ও বলা হয়।</p><h3 id="ক-ল্যাটেন্সি-কমানো-use-more-memory" tabindex="-1">ক. ল্যাটেন্সি কমানো (Use more Memory) <a class="header-anchor" href="#ক-ল্যাটেন্সি-কমানো-use-more-memory" aria-label="Permalink to &quot;ক. ল্যাটেন্সি কমানো (Use more Memory)&quot;">​</a></h3><p>আমরা যদি বারবার ক্যালকুলেশন না করে রেজাল্ট সেভ করে রাখি (Caching), তবে রেসপন্স টাইম বা ল্যাটেন্সি অনেক কমে যায়। কিন্তু এর জন্য আমাদের অতিরিক্ত মেমোরি বা RAM খরচ করতে হয়।</p><ul><li><strong>উদাহরণ:</strong> ডাটাবেস থেকে বারবার কুয়েরি না করে Redis বা Memcached-এ ডেটা রাখা।</li><li><strong>Tradeoff:</strong> Cost (RAM এর দাম বেশি) এবং ডেটা Stale হওয়ার ঝুঁকি।</li></ul><h3 id="খ-মেমোরি-বাঁচানো-accept-more-latency" tabindex="-1">খ. মেমোরি বাঁচানো (Accept more Latency) <a class="header-anchor" href="#খ-মেমোরি-বাঁচানো-accept-more-latency" aria-label="Permalink to &quot;খ. মেমোরি বাঁচানো (Accept more Latency)&quot;">​</a></h3><p>আমরা যদি মেমোরি বাঁচাতে চাই, তবে ডেটা কম্প্রেস (Compression) করে রাখতে পারি।</p><ul><li><strong>উদাহরণ:</strong> একটি ১জিবি ফাইলকে জিপ করে ১০০এমবি করা।</li><li><strong>Tradeoff:</strong> ফাইলটি পড়ার সময় আন-জিপ (Decompress) করতে হবে, যার জন্য CPU পাওয়ার লাগবে এবং সময় বেশি লাগবে (ল্যাটেন্সি বাড়বে)।</li></ul><h2 id="_2-throughput-vs-latency-থ্রুপুট-বনাম-ল্যাটেন্সি" tabindex="-1">2. Throughput vs Latency (থ্রুপুট বনাম ল্যাটেন্সি) <a class="header-anchor" href="#_2-throughput-vs-latency-থ্রুপুট-বনাম-ল্যাটেন্সি" aria-label="Permalink to &quot;2. Throughput vs Latency (থ্রুপুট বনাম ল্যাটেন্সি)&quot;">​</a></h2><p><strong>Throughput:</strong> একক সময়ে সিস্টেম কতটা কাজ (Requests per second) করতে পারে। <strong>Latency:</strong> একটি নির্দিষ্ট কাজ শেষ করতে কতটা সময় লাগে।</p><p>মাঝে মাঝে থ্রুপুট বাড়ানোর জন্য ল্যাটেন্সিকে সেক্রিফাইস করতে হয়।</p><h3 id="ব্যাচ-প্রসেসিং-batch-processing" tabindex="-1">ব্যাচ প্রসেসিং (Batch Processing) <a class="header-anchor" href="#ব্যাচ-প্রসেসিং-batch-processing" aria-label="Permalink to &quot;ব্যাচ প্রসেসিং (Batch Processing)&quot;">​</a></h3><p>মনে করুন, আপনি একটি লগার সিস্টেম বানাচ্ছেন। প্রতিটি লগ আসার সাথে সাথে ডিস্কে রাইট করলে (Low Latency), ডিস্কের I/O অপারেশন অনেক বেড়ে যাবে এবং সিস্টেম স্লো হয়ে যাবে। এর বদলে, আপনি ১০০টি লগ আসা পর্যন্ত মেমোরিতে জমিয়ে রাখলেন, তারপর একসাথে একবার ডিস্কে রাইট করলেন।</p><ul><li><strong>ফলাফল:</strong> সিস্টেমের থ্রুপুট অনেক বেড়ে গেল (কম I/O কল)।</li><li><strong>Tradeoff:</strong> ল্যাটেন্সি বাড়ল (প্রথম লগটিকে ১০০তম লগ আসা পর্যন্ত অপেক্ষা করতে হলো)।</li></ul><h3 id="প্যারালালিজম-parallelism" tabindex="-1">প্যারালালিজম (Parallelism) <a class="header-anchor" href="#প্যারালালিজম-parallelism" aria-label="Permalink to &quot;প্যারালালিজম (Parallelism)&quot;">​</a></h3><p>একই কাজ অনেকগুলো থ্রেডে ভাগ করে করলে থ্রুপুট বাড়ে, কিন্তু কনটেক্সট সুইচিং (Context Switching) বা নেটওয়ার্ক ওভারহেডের কারণে প্রতিটি রিকোয়েস্টের নিজস্ব ল্যাটেন্সি একটু বাড়তে পারে।</p><h2 id="_3-accuracy-vs-latency-নির্ভুলতা-বনাম-ল্যাটেন্সি" tabindex="-1">3. Accuracy vs Latency (নির্ভুলতা বনাম ল্যাটেন্সি) <a class="header-anchor" href="#_3-accuracy-vs-latency-নির্ভুলতা-বনাম-ল্যাটেন্সি" aria-label="Permalink to &quot;3. Accuracy vs Latency (নির্ভুলতা বনাম ল্যাটেন্সি)&quot;">​</a></h2><p>কখনো কখনো আমাদের ১০০% নির্ভুল উত্তরের চেয়ে &quot;দ্রুত উত্তর&quot; বেশি জরুরি হয়।</p><h3 id="approximate-computing" tabindex="-1">Approximate Computing <a class="header-anchor" href="#approximate-computing" aria-label="Permalink to &quot;Approximate Computing&quot;">​</a></h3><p>বিগ ডেটা সিস্টেমে বিলিয়ন বিলিয়ন ডেটা কাউন্ট করা (যেমন: Unique Visitors Count) অনেক সময়সাপেক্ষ। আমরা যদি এক্সাক্ট কাউন্ট চাই, তবে পুরো ডেটাবেস স্ক্যান করতে হবে, যা অনেক ধীর। এর বদলে আমরা <strong>HyperLogLog</strong> বা <strong>Bloom Filters</strong> এর মতো অ্যালগরিদম ব্যবহার করতে পারি।</p><ul><li><strong>সুবিধা:</strong> প্রায় ১ সেকেন্ডের মধ্যে উত্তর পাওয়া যায় (Low Latency)। মেমোরি খুব কম লাগে।</li><li><strong>Tradeoff:</strong> উত্তর ১০০% সঠিক নাও হতে পারে (১-২% এরর রেট থাকে)।</li></ul><h3 id="উদাহরণ-youtube-view-count" tabindex="-1">উদাহরণ: YouTube View Count <a class="header-anchor" href="#উদাহরণ-youtube-view-count" aria-label="Permalink to &quot;উদাহরণ: YouTube View Count&quot;">​</a></h3><p>যখন একটি ভিডিও ভাইরাল হয়, ইউটিউব রিয়েল-টাইমে প্রতিটি ভিউ কাউন্ট আপডেট করে না। তারা একটি আনুমানিক সংখ্যা দেখায় এবং পরে ব্যাকগ্রাউন্ডে সঠিক সংখ্যা ক্যালকুলেট করে আপডেট করে (&quot;301+ views&quot; সমস্যা যা আগে দেখা যেত)।</p><ul><li><strong>Takeaway:</strong> রিয়েল-টাইম এনালিটিক্সে অনেক সময় নির্ভুলতার চেয়ে স্পিড বেশি গুরুত্বপূর্ণ।</li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-11-tradeoffs/latency-tradeoffs.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const latencyTradeoffs = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  latencyTradeoffs as default
};
