import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"Push vs Pull Architecture (পুশ বনাম পুল আর্কিটেকচার)","description":"","frontmatter":{},"headers":[],"relativePath":"system-design/step-11-tradeoffs/push-pull.md","filePath":"system-design/step-11-tradeoffs/push-pull.md"}');
const _sfc_main = { name: "system-design/step-11-tradeoffs/push-pull.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="push-vs-pull-architecture-পুশ-বনাম-পুল-আর্কিটেকচার" tabindex="-1">Push vs Pull Architecture (পুশ বনাম পুল আর্কিটেকচার) <a class="header-anchor" href="#push-vs-pull-architecture-পুশ-বনাম-পুল-আর্কিটেকচার" aria-label="Permalink to &quot;Push vs Pull Architecture (পুশ বনাম পুল আর্কিটেকচার)&quot;">​</a></h1><p>সিস্টেম ডিজাইনের ক্ষেত্রে ডেটা বা মেসেজ কিভাবে এক জায়গা থেকে আরেক জায়গায় যাবে—তা নির্ধারণ করার জন্য <strong>Push</strong> এবং <strong>Pull</strong> মডেল দুটি অত্যন্ত গুরুত্বপূর্ণ। আসুন বিস্তারিত জেনে নিই।</p><h2 id="১-push-architecture-পুশ-আর্কিটেকচার" tabindex="-1">১. Push Architecture (পুশ আর্কিটেকচার) <a class="header-anchor" href="#১-push-architecture-পুশ-আর্কিটেকচার" aria-label="Permalink to &quot;১. Push Architecture (পুশ আর্কিটেকচার)&quot;">​</a></h2><p>Push মডেলে, সার্ভার বা প্রোডিউসার (Producer) নিজ থেকেই ক্লায়েন্ট বা কনজিউমারকে (Consumer) ডেটা পাঠিয়ে দেয়। ক্লায়েন্টকে বারবার রিকোয়েস্ট করতে হয় না।</p><h3 id="কিভাবে-কাজ-করে" tabindex="-1">কিভাবে কাজ করে? <a class="header-anchor" href="#কিভাবে-কাজ-করে" aria-label="Permalink to &quot;কিভাবে কাজ করে?&quot;">​</a></h3><p>producent বা সার্ভার যখনই নতুন ডেটা পায়, তখন সাথে সাথেই সেটি ক্লায়েন্টের কাছে &quot;পুশ&quot; করে দেয়। এটি রিয়েল-টাইম অ্যাপ্লিকেশনের জন্য খুব কার্যকর।</p><h3 id="উদাহরণ" tabindex="-1">উদাহরণ <a class="header-anchor" href="#উদাহরণ" aria-label="Permalink to &quot;উদাহরণ&quot;">​</a></h3><ul><li><strong>WebSockets:</strong> সার্ভার থেকে ক্লায়েন্টের ব্রাউজারে ইনস্ট্যান্ট মেসেজ পাঠানো।</li><li><strong>Mobile Notifications:</strong> অ্যাপ বন্ধ থাকলেও সার্ভার থেকে নোটিফিকেশন আসা।</li><li><strong>Email:</strong> কেউ মেইল পাঠালে মেইল সার্ভার সেটি আপনার ইনবক্সে পাঠিয়ে দেয়।</li></ul><h3 id="সুবিধা-pros" tabindex="-1">সুবিধা (Pros) <a class="header-anchor" href="#সুবিধা-pros" aria-label="Permalink to &quot;সুবিধা (Pros)&quot;">​</a></h3><ul><li><strong>Real-time:</strong> ডেটা তৈরি হওয়ার সাথে সাথেই পাওয়া যায়। ল্যাটেন্সি খুব কম।</li><li><strong>Less Client Overhead:</strong> ক্লায়েন্টকে বারবার সার্ভারে পোল (Poll) বা চেক করতে হয় না।</li></ul><h3 id="অসুবিধা-cons" tabindex="-1">অসুবিধা (Cons) <a class="header-anchor" href="#অসুবিধা-cons" aria-label="Permalink to &quot;অসুবিধা (Cons)&quot;">​</a></h3><ul><li><strong>Server Load:</strong> যদি অনেক ক্লায়েন্ট কানেক্টেড থাকে, তবে সার্ভারের ওপর চাপ পড়ে (Open Connections মেইনটেইন করতে হয়)।</li><li><strong>Consumer Overwhelmed:</strong> যদি প্রোডিউসার খুব দ্রুত ডেটা পাঠায় এবং কনজিউমার তা প্রসেস করতে না পারে (Slow Consumer), তবে সিস্টেম ক্র্যাশ করতে পারে। এই সমস্যাকে <strong>Backpressure</strong> দিয়ে হ্যান্ডেল করতে হয়।</li></ul><hr><h2 id="২-pull-architecture-পুল-আর্কিটেকচার" tabindex="-1">২. Pull Architecture (পুল আর্কিটেকচার) <a class="header-anchor" href="#২-pull-architecture-পুল-আর্কিটেকচার" aria-label="Permalink to &quot;২. Pull Architecture (পুল আর্কিটেকচার)&quot;">​</a></h2><p>Pull মডেলে, ক্লায়েন্ট বা কনজিউমার নিজ দায়িত্বে সার্ভার বা প্রোডিউসারের কাছে থেকে ডেটা চেয়ে নেয় (Request)।</p><h3 id="কিভাবে-কাজ-করে-1" tabindex="-1">কিভাবে কাজ করে? <a class="header-anchor" href="#কিভাবে-কাজ-করে-1" aria-label="Permalink to &quot;কিভাবে কাজ করে?&quot;">​</a></h3><p>ক্লায়েন্ট নির্দিষ্ট সময় পরপর (Periodic) বা প্রয়োজন অনুযায়ী সার্ভারে রিকোয়েস্ট পাঠায়—&quot;আমার জন্য নতুন কোনো ডেটা আছে কি?&quot; সার্ভার তখন রেসপন্স দেয়।</p><h3 id="উদাহরণ-1" tabindex="-1">উদাহরণ <a class="header-anchor" href="#উদাহরণ-1" aria-label="Permalink to &quot;উদাহরণ&quot;">​</a></h3><ul><li><strong>RSS Feeds:</strong> আপনার রিডার অ্যাপ নির্দিষ্ট সময় পরপর চেক করে নতুন ব্লগ পোস্ট এসেছে কিনা।</li><li><strong>REST API Polling:</strong> ক্লায়েন্ট প্রতি ৫ সেকেন্ড পরপর API কল করে স্ট্যাটাস চেক করে।</li><li><strong>Git Pull:</strong> আপনি <code>git pull</code> কমান্ড দিলে সার্ভার থেকে লেটেস্ট কোড আপনার মেশিনে আসে।</li></ul><h3 id="সুবিধা-pros-1" tabindex="-1">সুবিধা (Pros) <a class="header-anchor" href="#সুবিধা-pros-1" aria-label="Permalink to &quot;সুবিধা (Pros)&quot;">​</a></h3><ul><li><strong>Flow Control:</strong> কনজিউমার তার নিজের গতিতে (Space) ডেটা প্রসেস করতে পারে। সার্ভার ওভারলোড করে না।</li><li><strong>Simplicity:</strong> ইম্প্লিমেন্ট করা সহজ, কারণ এটি সাধারণ Request-Response মডেল।</li></ul><h3 id="অসুবিধা-cons-1" tabindex="-1">অসুবিধা (Cons) <a class="header-anchor" href="#অসুবিধা-cons-1" aria-label="Permalink to &quot;অসুবিধা (Cons)&quot;">​</a></h3><ul><li><strong>Latency:</strong> ডেটা আসার সাথে সাথেই পাওয়া যায় না। পরবর্তী পোলিং (Polling) পর্যন্ত অপেক্ষা করতে হয়।</li><li><strong>Wasted Resources:</strong> যদি নতুন কোনো ডেটা না থাকে, তবুও ঘন ঘন রিকোয়েস্ট পাঠানো হলে নেটওয়ার্ক ব্যান্ডউইথ এবং সার্ভার রিসোর্স নষ্ট হয় (Empty Responses)।</li></ul><hr><h2 id="৩-push-vs-pull-তুলনা" tabindex="-1">৩. Push vs Pull: তুলনা <a class="header-anchor" href="#৩-push-vs-pull-তুলনা" aria-label="Permalink to &quot;৩. Push vs Pull: তুলনা&quot;">​</a></h2><table tabindex="0"><thead><tr><th style="${ssrRenderStyle({ "text-align": "left" })}">বৈশিষ্ট্য</th><th style="${ssrRenderStyle({ "text-align": "left" })}">Push Model</th><th style="${ssrRenderStyle({ "text-align": "left" })}">Pull Model</th></tr></thead><tbody><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>Initiator</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">সার্ভার (Producer)</td><td style="${ssrRenderStyle({ "text-align": "left" })}">ক্লায়েন্ট (Consumer)</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>Real-time</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">হ্যাঁ, ল্যাটেন্সি অনেক কম</td><td style="${ssrRenderStyle({ "text-align": "left" })}">না, পোলিং ইন্টারভালের ওপর নির্ভর করে</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>State</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">স্টেটফুল (কানেকশন ধরে রাখতে হয়)</td><td style="${ssrRenderStyle({ "text-align": "left" })}">স্টেটলেস (Stateless)</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>Load Handling</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">সার্ভারকে কানেকশন ম্যানেজ করতে হয়</td><td style="${ssrRenderStyle({ "text-align": "left" })}">ক্লায়েন্ট নিজের গতিতে কাজ করে</td></tr><tr><td style="${ssrRenderStyle({ "text-align": "left" })}"><strong>Best For</strong></td><td style="${ssrRenderStyle({ "text-align": "left" })}">Chat Apps, Gaming, Notifications</td><td style="${ssrRenderStyle({ "text-align": "left" })}">RSS Feed, Background Sync, Analytics</td></tr></tbody></table><h2 id="৪-হাইব্রিড-অ্যাপ্রোচ-hybrid-approach" tabindex="-1">৪. হাইব্রিড অ্যাপ্রোচ (Hybrid Approach) <a class="header-anchor" href="#৪-হাইব্রিড-অ্যাপ্রোচ-hybrid-approach" aria-label="Permalink to &quot;৪. হাইব্রিড অ্যাপ্রোচ (Hybrid Approach)&quot;">​</a></h2><p>কিছু সিস্টেমে Push এবং Pull দুটোই ব্যবহার করা হয়। একে <strong>Hybrid</strong> বা <strong>Push-Pull</strong> মডেল বলে।</p><p><strong>উদাহরণ: Facebook News Feed</strong></p><ul><li>যাদের ফলোয়ার কম (সাধারণ ইউজার), তাদের জন্য <strong>Push</strong> মডেল ব্যবহার করা হতে পারে (Post করলেই ফ্রেন্ডদের ফিডে চলে যাবে)।</li><li>যাদের ফলোয়ার মিলিয়ন মিলিয়ন (সেলিব্রেটি), তাদের জন্য <strong>Pull</strong> মডেল ব্যবহার করা হয়। অর্থাৎ, তাদের পোস্ট সাথে সাথে সবার ফিডে পাঠানো হয় না। ইউজার যখন ফিড রিফ্রেশ করে (Pull Request), তখন সিস্টেম চেক করে ওই সেলিব্রেটির নতুন পোস্ট আছে কিনা। এটি সার্ভারের লোড কমায়।</li></ul></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("system-design/step-11-tradeoffs/push-pull.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const pushPull = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  pushPull as default
};
