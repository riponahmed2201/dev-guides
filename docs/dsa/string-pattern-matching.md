# String Pattern Matching

String Pattern Matching рж╣рж▓рзЛ ржПржХржЯрж┐ ржЯрзЗржХрзНрж╕ржЯрзЗрж░ (Text) ржоржзрзНржпрзЗ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржПржХржЯрж┐ ржкрзНржпрж╛ржЯрж╛рж░рзНржи (Pattern) ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рж╛рж░ ржкрзНрж░ржХрзНрж░рж┐рзЯрж╛ред ржПржЯрж┐ рж╕рж╛рж░рзНржЪ ржЗржЮрзНржЬрж┐ржи, ржбрзЗржЯрж╛ ржорж╛ржЗржирж┐ржВ ржПржмржВ ржирзЗржЯржУрзЯрж╛рж░рзНржХ рж╕рж┐ржХрж┐ржЙрж░рж┐ржЯрж┐рждрзЗ ржмрзНржпрж╛ржкржХржнрж╛ржмрзЗ ржмрзНржпржмрж╣рзГржд рж╣рзЯред

## рзз. ржирзЗржн ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржорзНржпрж╛ржЪрж┐ржВ (Naive Pattern Matching)

ржПржЯрж┐ рж╕ржмржЪрзЗрзЯрзЗ рж╕рж╣ржЬ ржкржжрзНржзрждрж┐ред ржПржЦрж╛ржирзЗ ржкрзНржпрж╛ржЯрж╛рж░рзНржиржЯрж┐ржХрзЗ ржЯрзЗржХрзНрж╕ржЯрзЗрж░ ржкрзНрж░рждрж┐ржЯрж┐ ржкржЬрж┐рж╢ржирзЗрж░ рж╕рж╛ржерзЗ ржорж┐рж▓рж┐рзЯрзЗ ржжрзЗржЦрж╛ рж╣рзЯред

**Time Complexity:** $O(n \times m)$, ржпрзЗржЦрж╛ржирзЗ n ржЯрзЗржХрзНрж╕ржЯрзЗрж░ ржжрзИрж░рзНржШрзНржп ржПржмржВ m ржкрзНржпрж╛ржЯрж╛рж░рзНржирзЗрж░ ржжрзИрж░рзНржШрзНржпред

#### ЁЯЫа ржХрж░рзНржоржкржжрзНржзрждрж┐ (Step-by-Step Logic)

1. ржЯрзЗржХрзНрж╕ржЯрзЗрж░ ржкрзНрж░ржержо ржерзЗржХрзЗ ржкрзНрж░рждрж┐ржЯрж┐ рж╕ржорзНржнржмржкрж░ ржкржЬрж┐рж╢ржи `i` ржПрж░ ржЬржирзНржп ржкрзНржпрж╛ржЯрж╛рж░рзНржиржЯрж┐ ржорж┐рж▓рж┐рзЯрзЗ ржжрзЗржЦрж╛ рж╢рзБрж░рзБ ржХрж░рзБржиред
2. рж╕рж╛ржм-рж▓рзБржкрзЗрж░ ржорж╛ржзрзНржпржорзЗ ржкрзНржпрж╛ржЯрж╛рж░рзНржирзЗрж░ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ржЧрзБрж▓рзЛ `text[i+j]` ржПрж░ рж╕рж╛ржерзЗ ржЪрзЗржХ ржХрж░рзБржиред
3. ржпржжрж┐ ржХрзЛржирзЛ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржирж╛ ржорж┐рж▓рзЗ ржпрж╛рзЯ, рждржмрзЗ рж╕рж╛ржм-рж▓рзБржк ржмрзНрж░рзЗржХ ржХрж░рзЗ ржкрж░рзЗрж░ `i` рждрзЗ ржпрж╛ржиред
4. ржпржжрж┐ ржкрзНржпрж╛ржЯрж╛рж░рзНржирзЗрж░ рж╕ржм ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржорж┐рж▓рзЗ ржпрж╛рзЯ (`j == m`), рждржмрзЗ рж╕рзЗржЗ ржЗржиржбрзЗржХрзНрж╕ржЯрж┐ ржкрзНрж░рж┐ржирзНржЯ ржХрж░рзБржиред

```java
public void search(String text, String pat) {
    int n = text.length();
    int m = pat.length();
    for (int i = 0; i <= n - m; i++) {
        int j;
        for (j = 0; j < m; j++) {
            if (text.charAt(i + j) != pat.charAt(j)) break;
        }
        if (j == m) System.out.println("Pattern found at index " + i);
    }
}
```

```python
def naive_search(text, pat):
    n, m = len(text), len(pat)
    for i in range(n - m + 1):
        if text[i : i + m] == pat:
            print(f"Pattern found at index {i}")
```

## рзи. ржХрзЗржПржоржкрж┐ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо (KMP Algorithm Basics)

KMP (Knuth-Morris-Pratt) ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо ржирзЗржн ржкржжрзНржзрждрж┐рж░ ржЪрзЗрзЯрзЗ ржжржХрзНрж╖ ржХрж╛рж░ржг ржПржЯрж┐ ржЗрждрж┐ржоржзрзНржпрзЗ ржорзНржпрж╛ржЪ рж╣ржУрзЯрж╛ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ржЧрзБрж▓рзЛржХрзЗ ржкрзБржирж░рж╛рзЯ ржЪрзЗржХ ржХрж░рзЗ ржирж╛ред ржПрж░ ржорзВрж▓ ржнрж┐рждрзНрждрж┐ рж╣рж▓рзЛ **LPS (Longest Proper Prefix which is also Suffix)** ржЕрзНржпрж╛рж░рзЗред

**Time Complexity:** $O(n + m)$

#### ЁЯЫа ржХрж░рзНржоржкржжрзНржзрждрж┐ (Step-by-Step Logic)

1. ржкрзНрж░ржержорзЗ **LPS ржЕрзНржпрж╛рж░рзЗ** рждрзИрж░рж┐ ржХрж░рзБржи ржпрж╛ рж▓рзБржк (Cycles) ржмрж╛ рж░рж┐ржкрж┐ржЯ рж╣ржУрзЯрж╛ рж╕рж╛ржм-рж╕рзНржЯрзНрж░рж┐ржВ ржПрж░ рждржерзНржп ржзрж╛рж░ржг ржХрж░рзЗред
2. ржЯрзЗржХрзНрж╕ржЯ `txt` ржПржмржВ ржкрзНржпрж╛ржЯрж╛рж░рзНржи `pat` ржПрж░ ржЬржирзНржп ржжрзБржЯрж┐ ржкрзЯрзЗржирзНржЯрж╛рж░ `i` ржПржмржВ `j` ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзБржиред
3. ржпржжрж┐ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржорж┐рж▓рзЗ ржпрж╛рзЯ, рждржмрзЗ ржЙржнрзЯ ржкрзЯрзЗржирзНржЯрж╛рж░ ржПржХ ржШрж░ ржмрж╛рзЬрж┐рзЯрзЗ ржжрж┐ржиред
4. ржпржжрж┐ ржорзНржпрж╛ржЪ ржкрзВрж░рзНржг рж╣рзЯ (`j == m`), рждржмрзЗ рж░рзЗржЬрж╛рж▓рзНржЯ рж╕рзНржЯрзЛрж░ ржХрж░рзБржи ржПржмржВ `j` ржХрзЗ `lps[j-1]` ржП ржмрзНржпрж╛ржХ-ржЯрзНрж░рзНржпрж╛ржХ ржХрж░рзБржиред
5. ржпржжрж┐ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржирж╛ ржорж┐рж▓рзЗ ржПржмржВ `j != 0` рж╣рзЯ, рждржмрзЗ ржкрзНржпрж╛ржЯрж╛рж░рзНржиржЯрж┐ржХрзЗ ржЕржкрзНрж░рзЯрзЛржЬржирзАрзЯ рждрзБрж▓ржирж╛ ржирж╛ ржХрж░рзЗ `j = lps[j-1]` ржкржЬрж┐рж╢ржирзЗ рж╕рж░рж┐рзЯрзЗ ржЖржирзБржиред

```python
def computeLPSArray(pat, m, lps):
    length = 0
    lps[0] = 0
    i = 1
    while i < m:
        if pat[i] == pat[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length-1]
            else:
                lps[i] = 0
                i += 1

def KMPSearch(pat, txt):
    m, n = len(pat), len(txt)
    lps = [0]*m
    computeLPSArray(pat, m, lps)
    i = j = 0
    while i < n:
        if pat[j] == txt[i]:
            i += 1
            j += 1
        if j == m:
            print(f"Found pattern at index {i-j}")
            j = lps[j-1]
        elif i < n and pat[j] != txt[i]:
            if j != 0:
                j = lps[j-1]
            else:
                i += 1
```

## рзй. рж░ржмрж┐ржи-ржХрж╛рж░рзНржк ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо (Rabin-Karp Algorithm)

рж░ржмрж┐ржи-ржХрж╛рж░рзНржк ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржо **Hashing** ржПрж░ ржорж╛ржзрзНржпржорзЗ ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рзЗред ржпржжрж┐ рж╣рзНржпрж╛рж╢ ржнрзНржпрж╛рж▓рзБ ржорж┐рж▓рзЗ ржпрж╛рзЯ, рждржмрзЗржЗ ржХрзЗржмрж▓ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржмрж╛ржЗ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржЪрзЗржХ ржХрж░рж╛ рж╣рзЯред ржПрж░ ржЬржирзНржп **Rolling Hash** ржмрзНржпржмрж╣рзГржд рж╣рзЯред

**Average Time Complexity:** $O(n + m)$

## рзк. ржЕрзНржпрж╛ржирж╛ржЧрзНрж░рж╛ржо рж╕рж╛рж░рзНржЪ (Anagram Search)

ржПржХржЯрж┐ ржЯрзЗржХрзНрж╕ржЯрзЗрж░ ржоржзрзНржпрзЗ ржХрзЛржирзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ ржкрзНржпрж╛ржЯрж╛рж░рзНржирзЗрж░ ржЕрзНржпрж╛ржирж╛ржЧрзНрж░рж╛ржо (Anagram) ржЖржЫрзЗ ржХрж┐ржирж╛ рждрж╛ ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рж╛ред ржПржЯрж┐ рж╕рж╛ржзрж╛рж░ржгржд рж╕рзНрж▓рж╛ржЗржбрж┐ржВ ржЙржЗржирзНржбрзЛ ржПржмржВ ржлрзНрж░рж┐ржХрзЛржпрж╝рзЗржирзНрж╕рж┐ ржЕрзНржпрж╛рж░рзЗ (Frequency Array) ржжрж┐рзЯрзЗ ржХрж░рж╛ рж╣рзЯред

#### ЁЯЫа ржХрж░рзНржоржкржжрзНржзрждрж┐ (Step-by-Step Logic)

1. ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржПржмржВ ржЯрзЗржХрзНрж╕ржЯрзЗрж░ ржкрзНрж░ржержо ржЙржЗржирзНржбрзЛрж░ ржЬржирзНржп ржжрзБржЯрж┐ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржЕрзНржпрж╛рж░рзЗ рждрзИрж░рж┐ ржХрж░рзБржиред
2. ржкрзНржпрж╛ржЯрж╛рж░рзНржирзЗрж░ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ржЧрзБрж▓рзЛрж░ ржХрж╛ржЙржирзНржЯ ржПржмржВ ржЯрзЗржХрзНрж╕ржЯрзЗрж░ ржкрзНрж░ржержо `m` ржЯрж┐ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░рзЗрж░ ржХрж╛ржЙржирзНржЯ ржирж┐ржиред
3. ржЙржЗржирзНржбрзЛржЯрж┐ рж╕рзНржЯрзНрж░рж┐ржВ-ржПрж░ рж╢рзЗрж╖ ржкрж░рзНржпржирзНржд рж╕рзНрж▓рж╛ржЗржб ржХрж░рзБржиред
4. ржкрзНрж░рждрж┐ржЯрж┐ ржзрж╛ржкрзЗ ржкрзНржпрж╛ржЯрж╛рж░рзНржирзЗрж░ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржЕрзНржпрж╛рж░рзЗрж░ рж╕рж╛ржерзЗ ржЙржЗржирзНржбрзЛрж░ ржлрзНрж░рж┐ржХрзЛрзЯрзЗржирзНрж╕рж┐ ржЕрзНржпрж╛рж░рзЗ рждрзБрж▓ржирж╛ ржХрж░рзБржиред
5. ржЙржЗржирзНржбрзЛ рж╕рзНрж▓рж╛ржЗржб ржХрж░рж╛рж░ рж╕ржорзЯ ржирждрзБржи ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ ржпрзБржХрзНржд ржХрж░рзБржи ржПржмржВ ржкрзБрж░рж╛ржирзЛ ржХрзНржпрж╛рж░рзЗржХрзНржЯрж╛рж░ рж░рж┐ржорзБржн ржХрж░рзБржиред

```python
def anagramSearch(txt, pat):
    n, m = len(txt), len(pat)
    if m > n: return

    countP, countT = [0]*256, [0]*256
    for i in range(m):
        countP[ord(pat[i])] += 1
        countT[ord(txt[i])] += 1

    for i in range(m, n):
        if countP == countT:
            print(f"Anagram found at index {i-m}")
        countT[ord(txt[i])] += 1
        countT[ord(txt[i-m])] -= 1

    if countP == countT:
        print(f"Anagram found at index {n-m}")
```

## рж╕рзНржЯрзНрж░рж┐ржВ ржорзНржпрж╛ржЪрж┐ржВ ржПрж░ ржмрзНржпржмрж╣рж╛рж░ (Applications)

- **Search Engines:** ржЯрзЗржХрзНрж╕ржЯ рж╕рж╛рж░рзНржЪ ржХрж░рж╛рж░ ржЬржирзНржпред
- **DNA Sequencing:** ржмрж╛рзЯрзЛржЗржиржлрж░ржорзНржпрж╛ржЯрж┐ржХрзНрж╕рзЗ ржбрж┐ржПржиржП ржкрзНржпрж╛ржЯрж╛рж░рзНржи ржЦрзЛржБржЬрж╛рж░ ржЬржирзНржпред
- **Plagiarism Detection:** рж▓рзЗржЦрж╛ ржиржХрж▓ ржХрж░рж╛ рж╣рзЯрзЗржЫрзЗ ржХрж┐ржирж╛ рждрж╛ ржпрж╛ржЪрж╛ржЗ ржХрж░рждрзЗред
- **Intrusion Detection:** ржирзЗржЯржУрзЯрж╛рж░рзНржХ ржкрзНржпрж╛ржХрзЗржЯ ржоржирж┐ржЯрж░ ржХрж░рждрзЗред
