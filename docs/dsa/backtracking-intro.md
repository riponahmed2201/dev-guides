# 18. Backtracking Introduction

**Backtracking** рж╣рж▓рзЛ ржПржХржЯрж┐ ржЕрзНржпрж╛рж▓ржЧрж░рж┐ржжржорж┐ржХ ржкржжрзНржзрждрж┐ ржпрж╛ ржХрзЛржирзЛ рж╕ржорж╕рзНржпрж╛рж░ рж╕ржм рж╕ржорзНржнрж╛ржмрзНржп рж╕ржорж╛ржзрж╛ржи ржЦрзБржБржЬрзЗ ржмрзЗрж░ ржХрж░рж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзЗред ржПржЯрж┐ ржорзВрж▓ржд ржПржХржЯрж┐ ржмрзНрж░рзБржЯ-ржлрзЛрж░рзНрж╕ (Brute-force) ржПржкрзНрж░рзЛржЪ, ржХрж┐ржирзНрждрзБ ржПржЯрж┐ ржпржЦржиржЗ ржмрзБржЭрждрзЗ ржкрж╛рж░рзЗ ржпрзЗ ржмрж░рзНрждржорж╛ржи ржкржержЯрж┐ рж╕ржарж┐ржХ рж╕ржорж╛ржзрж╛ржирзЗрж░ ржжрж┐ржХрзЗ ржпрж╛ржмрзЗ ржирж╛, рждржЦржиржЗ рж╕рзЗржЯрж┐ ржлрж┐рж░рзЗ ржЖрж╕рзЗ (Backtrack) ржПржмржВ ржЕржирзНржп ржкржерзЗ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзЗред

---

## 1. ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВ ржПржкрзНрж░рзЛржЪ (Backtracking Approach)

ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВ ржЕржирзЗржХржЯрж╛ ржПржХржЯрж┐ ржЧрзЛрж▓ржХржзрж╛ржБржзрж╛рзЯ (Maze) рж╣рж╛ржБржЯрж╛рж░ ржорждрзЛред ржпржжрж┐ ржЖржкржирж┐ ржПржХржЯрж┐ рж░рж╛рж╕рзНрждрж╛рзЯ ржЧрж┐рзЯрзЗ ржжрзЗржЦрзЗржи рж╕рзЗржЯрж┐ ржмржирзНржз, рждржмрзЗ ржЖржкржирж┐ ржЖржЧрзЗрж░ ржорзЛрзЬрзЗ ржлрж┐рж░рзЗ ржЖрж╕рзЗржи ржПржмржВ ржЕржирзНржп ржЖрж░рзЗржХржЯрж┐ рж░рж╛рж╕рзНрждрж╛ ржмрзЗржЫрзЗ ржирзЗржиред

### ЁЯЫа ржорзВрж▓ ржзрж╛ржкрж╕ржорзВрж╣ (Core Steps)

1. **Choose:** ржПржХржЯрж┐ рж╕ржорзНржнрж╛ржмрзНржп ржЕржкрж╢ржи ржмрзЗржЫрзЗ ржирж┐ржиред
2. **Explore:** рж╕рзЗржЗ ржЕржкрж╢ржиржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ рж╕рж╛ржоржирзЗрж░ ржжрж┐ржХрзЗ ржПржЧрж┐рзЯрзЗ ржпрж╛ржи (Recursion)ред
3. **Backtrack:** ржпржжрж┐ ржжрзЗржЦрзЗржи ржПржЗ ржкржерзЗ ржХрзЛржирзЛ рж╕ржорж╛ржзрж╛ржи ржирзЗржЗ, рждржмрзЗ ржЖржЧрзЗрж░ ржЕржмрж╕рзНржерж╛рзЯ ржлрж┐рж░рзЗ ржпрж╛ржи ржПржмржВ ржмрж╛ржЫрж╛ржЗ ржХрж░рж╛ ржЕржкрж╢ржиржЯрж┐ ржмрж╛ржж ржжрж┐рзЯрзЗ ржирждрзБржи ржХрж┐ржЫрзБ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред

---

## 2. рж╕рзНржЯрзЗржЯ рж╕рзНржкрзЗрж╕ ржЯрзНрж░рж┐ (State Space Tree)

ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВрзЯрзЗрж░ рж╕ржм рж╕ржорзНржнрж╛ржмрзНржп рж╕рж┐ржжрзНржзрж╛ржирзНржд ржПржмржВ рждрж╛ржжрзЗрж░ ржлрж▓рж╛ржлрж▓ржХрзЗ ржПржХржЯрж┐ ржЯрзНрж░рж┐рж░ ржорж╛ржзрзНржпржорзЗ ржкрзНрж░ржХрж╛рж╢ ржХрж░рж╛ рж╣рзЯ, ржпрж╛ржХрзЗ **State Space Tree** ржмрж╛ **Decision Tree** ржмрж▓рж╛ рж╣рзЯред

```text
       Root (Start)
      /      \
   Path 1   Path 2
    / \      / \
   S   F     F  S
(S=Success, F=Failure)
```

---

## 3. ржкрзНрж░рзБржирж┐ржВ (Pruning)

ржпржжрж┐ ржЖржорж░рж╛ ржЖржЧрзЗржЗ ржмрзБржЭрждрзЗ ржкрж╛рж░рж┐ ржпрзЗ ржХрзЛржирзЛ ржПржХржЯрж┐ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ рж╕рж╛ржм-ржЯрзНрж░рж┐ (Sub-tree) ржерзЗржХрзЗ рж╕ржарж┐ржХ рж╕ржорж╛ржзрж╛ржи ржкрж╛ржУрзЯрж╛ рж╕ржорзНржнржм ржирзЯ, рждржмрзЗ ржЖржорж░рж╛ рж╕рзЗржЗ ржкржерзЗ ржЖрж░ ржЪрзЗржХ ржХрж░рж┐ ржирж╛ред ржПржЗ рж╕ржорзЯ ржмрж╛ржБржЪрж╛ржирзЛрж░ ржкржжрзНржзрждрж┐ржХрзЗ ржмрж▓рж╛ рж╣рзЯ **Pruning**ред ржПржЯрж┐ ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВрзЯрзЗрж░ ржЧрждрж┐ ржЕржирзЗржХ ржмрж╛рзЬрж┐рзЯрзЗ ржжрзЗрзЯред

---

## 4. ржПржи-ржХрзБржЗржирж╕ ржкрзНрж░ржмрж▓рзЗржо (N-Queens Problem - Basic)

ржПржХржЯрж┐ $N \times N$ ржЪрзЗрж╕ржмрзЛрж░рзНржбрзЗ N рж╕ржВржЦрзНржпржХ рж░рж╛ржирзАржХрзЗ ржПржоржиржнрж╛ржмрзЗ ржмрж╕рж╛рждрзЗ рж╣ржмрзЗ ржпрж╛рждрзЗ ржХрзЗржЙ ржХрж╛ржЙржХрзЗ ржЖржХрзНрж░ржоржг ржХрж░рждрзЗ ржирж╛ ржкрж╛рж░рзЗред

#### ЁЯЫа ржХрж░рзНржоржкржжрзНржзрждрж┐ (Step-by-Step Logic)

1. ржкрзНрж░ржержо рж░рзМ (Row) ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рзБржиред
2. ржкрзНрж░рждрж┐ржЯрж┐ ржХрж▓рж╛ржорзЗ рж░рж╛ржирзА ржмрж╕рж╛ржирзЛрж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзБржиред
3. ржЪрзЗржХ ржХрж░рзБржи ржмрж░рзНрждржорж╛ржи ржкржЬрж┐рж╢ржиржЯрж┐ ржирж┐рж░рж╛ржкржж (Safe) ржХрж┐ ржирж╛ (ржПржХржЗ ржХрж▓рж╛ржо, рж░рзЛ ржмрж╛ ржбрж╛рзЯрж╛ржЧрзЛржирж╛рж▓рзЗ ржЕржирзНржп рж░рж╛ржирзА ржирзЗржЗ)ред
4. ржпржжрж┐ ржирж┐рж░рж╛ржкржж рж╣рзЯ, рж░рж╛ржирзА ржмрж╕рж╛ржи ржПржмржВ ржкрж░рзЗрж░ рж░рзЛ-рждрзЗ ржпрж╛ржиред
5. ржпржжрж┐ ржХрзЛржирзЛ ржХрж▓рж╛ржоржЗ ржирж┐рж░рж╛ржкржж ржирж╛ рж╣рзЯ, рждржмрзЗ ржЖржЧрзЗрж░ рж░рзЛ-рждрзЗ ржлрж┐рж░рзЗ ржпрж╛ржи ржПржмржВ ржкрзВрж░рзНржмржмрж░рзНрждрзА рж░рж╛ржирзАрж░ ржкржЬрж┐рж╢ржи ржкрж░рж┐ржмрж░рзНрждржи ржХрж░рзБржи (**Backtrack**)ред

#### Implementation

```java
// Java N-Queens
public class NQueens {
    public void solveNQueens(int n) {
        char[][] board = new char[n][n];
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                board[i][j] = '.';
        solve(0, board, n);
    }

    private void solve(int col, char[][] board, int n) {
        if (col == n) {
            printBoard(board, n);
            return;
        }
        for (int row = 0; row < n; row++) {
            if (isSafe(row, col, board, n)) {
                board[row][col] = 'Q';
                solve(col + 1, board, n);
                board[row][col] = '.'; // Backtrack
            }
        }
    }

    private boolean isSafe(int row, int col, char[][] board, int n) {
        for (int i = 0; i < col; i++)
            if (board[row][i] == 'Q') return false;
        for (int i = row, j = col; i >= 0 && j >= 0; i--, j--)
            if (board[i][j] == 'Q') return false;
        for (int i = row, j = col; i < n && j >= 0; i++, j--)
            if (board[i][j] == 'Q') return false;
        return true;
    }

    private void printBoard(char[][] board, int n) {
        for (int i = 0; i < n; i++) {
            System.out.println(new String(board[i]));
        }
        System.out.println();
    }
}
```

```python
# Python N-Queens
def solve_n_queens(n):
    board = [['.' for _ in range(n)] for _ in range(n)]

    def is_safe(row, col):
        for i in range(col):
            if board[row][i] == 'Q': return False
        for i, j in zip(range(row, -1, -1), range(col, -1, -1)):
            if board[i][j] == 'Q': return False
        for i, j in zip(range(row, n, 1), range(col, -1, -1)):
            if board[i][j] == 'Q': return False
        return True

    def solve(col):
        if col == n:
            for row in board:
                print("".join(row))
            print()
            return
        for row in range(n):
            if is_safe(row, col):
                board[row][col] = 'Q'
                solve(col + 1)
                board[row][col] = '.' # Backtrack

    solve(0)
```

---

## 5. рж░тАНрзНржпрж╛ржЯ ржЗржи ржЖ ржорзЗржЬ (Rat in a Maze)

ржПржХржЯрж┐ ржЧрзНрж░рж┐ржбрзЗ ржПржХржЯрж┐ ржЗржБржжрзБрж░ржХрзЗ (0,0) ржерзЗржХрзЗ рж╢рзБрж░рзБ ржХрж░рзЗ ржбрзЗрж╕рзНржЯрж┐ржирзЗрж╢ржирзЗ ржкрзМржБржЫрж╛рждрзЗ рж╣ржмрзЗред ржЧрзНрж░рж┐ржбрзЗ ржХрж┐ржЫрзБ ржмрзНрж▓ржХ ржмрж╛ ржмрж╛ржзрж╛ ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред

#### ЁЯЫа ржХрж░рзНржоржкржжрзНржзрждрж┐ (Step-by-Step Logic)

1. ржмрж░рзНрждржорж╛ржи ржШрж░ржЯрж┐ ржирж┐рж░рж╛ржкржж ржХрж┐ ржирж╛ ржЪрзЗржХ ржХрж░рзБржи (ржмрж╛ржЙржирзНржбрж╛рж░рж┐рж░ ржнрзЗрждрж░рзЗ ржПржмржВ ржХрзЛржирзЛ ржмрзНрж▓ржХ ржирзЗржЗ)ред
2. ржпржжрж┐ ржирж┐рж░рж╛ржкржж рж╣рзЯ, ржШрж░ржЯрж┐ржХрзЗ ржорж╛рж░рзНржХ ржХрж░рзБржи ржПржмржВ ржЪрж╛рж░ржжрж┐ржХрзЗ (ржбрж╛ржирзЗ, ржмрж╛ржорзЗ, ржЙржкрж░рзЗ, ржирж┐ржЪрзЗ) ржЪрзЗржХ ржХрж░рзБржиред
3. ржпржжрж┐ рж╕ржорж╛ржзрж╛ржи ржирж╛ ржкрж╛ржУрзЯрж╛ ржпрж╛рзЯ, рждржмрзЗ ржШрж░ржЯрж┐ржХрзЗ ржЖржи-ржорж╛рж░рзНржХ (Unmark) ржХрж░рзБржи ржПржмржВ ржлрж┐рж░рзЗ ржЖрж╕рзБржиред

#### Implementation

```java
// Java Rat in a Maze
public class RatInMaze {
    public boolean solveMaze(int[][] maze, int n) {
        int[][] sol = new int[n][n];
        if (!solve(maze, 0, 0, sol, n)) return false;
        printSolution(sol, n);
        return true;
    }

    private boolean solve(int[][] maze, int x, int y, int[][] sol, int n) {
        if (x == n - 1 && y == n - 1 && maze[x][y] == 1) {
            sol[x][y] = 1;
            return true;
        }
        if (isSafe(maze, x, y, n)) {
            sol[x][y] = 1;
            if (solve(maze, x + 1, y, sol, n)) return true;
            if (solve(maze, x, y + 1, sol, n)) return true;
            sol[x][y] = 0; // Backtrack
            return false;
        }
        return false;
    }

    private boolean isSafe(int[][] maze, int x, int y, int n) {
        return (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] == 1);
    }

    private void printSolution(int[][] sol, int n) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) System.out.print(" " + sol[i][j] + " ");
            System.out.println();
        }
    }
}
```

```python
# Python Rat in a Maze
def solve_maze(maze, n):
    sol = [[0 for _ in range(n)] for _ in range(n)]

    def is_safe(x, y):
        return 0 <= x < n and 0 <= y < n and maze[x][y] == 1

    def solve(x, y):
        if x == n - 1 and y == n - 1 and maze[x][y] == 1:
            sol[x][y] = 1
            return True
        if is_safe(x, y):
            sol[x][y] = 1
            if solve(x + 1, y): return True
            if solve(x, y + 1): return True
            sol[x][y] = 0 # Backtrack
            return False
        return False

    if solve(0, 0):
        for row in sol:
            print(row)
    else:
        print("No solution")
```

---

## 6. рж╕рж╛ржмрж╕рзЗржЯ ржЬрзЗржирж╛рж░рзЗрж╢ржи (Subset Generation)

ржПржХржЯрж┐ рж╕рзЗржЯрзЗрж░ рж╕ржм рж╕ржорзНржнрж╛ржмрзНржп рж╕рж╛ржмрж╕рзЗржЯ ржмрзЗрж░ ржХрж░рж╛ (ржпрзЗржоржи: {1, 2} ржПрж░ рж╕рж╛ржмрж╕рзЗржЯ { }, {1}, {2}, {1, 2})ред

#### ЁЯЫа ржХрж░рзНржоржкржжрзНржзрждрж┐ (Step-by-Step Logic)

1. ржкрзНрж░рждрж┐ржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯрзЗрж░ ржЬржирзНржп ржжрзБржЯрж┐ рж╕рж┐ржжрзНржзрж╛ржирзНржд ржерж╛ржХрзЗ: рж╣рзЯ ржПрж▓рж┐ржорзЗржирзНржЯржЯрж┐ рж╕рж╛ржмрж╕рзЗржЯрзЗ ржерж╛ржХржмрзЗ, ржЕржержмрж╛ ржерж╛ржХржмрзЗ ржирж╛ред
2. ржПржХржЯрж┐ ржбрж┐рж╕рж┐рж╢ржи ржЯрзНрж░рж┐ рждрзИрж░рж┐ ржХрж░рзБржи ржпрзЗржЦрж╛ржирзЗ ржкрзНрж░рждрж┐ржЯрж┐ ржзрж╛ржкрзЗ ржПржХржЯрж┐ ржПрж▓рж┐ржорзЗржирзНржЯ ржпрзЛржЧ ржХрж░рж╛ рж╣рзЯ ржмрж╛ ржмрж╛ржж ржжрзЗржУрзЯрж╛ рж╣рзЯред

#### Implementation

```java
// Java Subset Generation
import java.util.*;
public class Subsets {
    public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        generate(0, nums, new ArrayList<>(), res);
        return res;
    }

    private void generate(int index, int[] nums, List<Integer> current, List<List<Integer>> res) {
        res.add(new ArrayList<>(current));
        for (int i = index; i < nums.length; i++) {
            current.add(nums[i]);
            generate(i + 1, nums, current, res);
            current.remove(current.size() - 1); // Backtrack
        }
    }
}
```

```python
# Python Subset Generation
def subsets(nums):
    res = []
    def generate(index, current):
        res.append(current[:])
        for i in range(index, len(nums)):
            current.append(nums[i])
            generate(i + 1, current)
            current.pop() # Backtrack
    generate(0, [])
    return res
```

---

## ЁЯУК ржХржоржкрзНрж▓рзЗржХрзНрж╕рж┐ржЯрж┐ ржЕрзНржпрж╛ржирж╛рж▓рж╛ржЗрж╕рж┐рж╕ (Complexity Analysis)

- **Time Complexity:** ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВ рж╕рж╛ржзрж╛рж░ржгржд ржПржХрзНрж╕ржкрзЛржирзЗржирж╢рж┐рзЯрж╛рж▓ рж╣рзЯред ржпрзЗржоржи, N-Queens-ржПрж░ ржЬржирзНржп ржПржЯрж┐ **O(n!)**, ржПржмржВ рж╕рж╛ржмрж╕рзЗржЯ ржЬрзЗржирж╛рж░рзЗрж╢ржирзЗрж░ ржЬржирзНржп **O(2тБ┐)**ред
- **Space Complexity:** рж░рж┐ржХрж╛рж░рзНрж╕ржи рж╕рзНржЯрзНржпрж╛ржХрзЗрж░ ржЧржнрзАрж░рждрж╛рж░ ржУржкрж░ ржирж┐рж░рзНржнрж░ ржХрж░рзЗ, рж╕рж╛ржзрж╛рж░ржгржд **O(n)**ред

---

> [!IMPORTANT]
> ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВ ржмрзНржпржмрж╣рж╛рж░рзЗрж░ рж╕ржорзЯ **Pruning** ржЦрзБржмржЗ ржЧрзБрж░рзБрждрзНржмржкрзВрж░рзНржгред рж╕ржарж┐ржХ ржХржирзНржбрж┐рж╢ржи рж╕рзЗржЯ ржХрж░рж▓рзЗ ржПржЯрж┐ ржХрзЛржбрзЗрж░ ржкрж╛рж░ржлрж░ржорзНржпрж╛ржирзНрж╕ ржЕржирзЗржХрж╛ржВрж╢рзЗржЗ ржЙржирзНржиржд ржХрж░рждрзЗ ржкрж╛рж░рзЗред

---

> [!TIP]
> ржмрзНржпрж╛ржХржЯрзНрж░рзНржпрж╛ржХрж┐ржВ ржХрзЛржб рж▓рзЗржЦрж╛рж░ рж╕ржорзЯ рж╕ржмрж╕ржорзЯ `visited` ржЕрзНржпрж╛рж░рзЗ ржмрж╛ рж╕рзНржЯрзЗржЯ ржЪрзЗржЮрзНржЬ ржХрж░рж╛рж░ ржкрж░ рж╕рзЗржЯрж┐ ржкрзБржирж░рж╛рзЯ ржЖржЧрзЗрж░ ржЕржмрж╕рзНржерж╛рзЯ ржлрж┐рж░рж┐рзЯрзЗ ржЖржирж╛рж░ (Undo step) ржХржерж╛ ржоржирзЗ рж░рж╛ржЦржмрзЗржиред
