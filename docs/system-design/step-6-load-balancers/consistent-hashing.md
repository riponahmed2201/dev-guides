# Consistent Hashing

ডিস্ট্রিবিউটেড সিস্টেম যখন অনেক বড় হয়ে যায় এবং অনেকগুলো ডেটাবেস বা ক্যাশ সার্ভার থাকে, তখন ডেটা কোন সার্ভারে যাবে তা ঠিক করার জন্য সাধারণ হ্যাশিং পর্যাপ্ত নয়। এখানেই **Consistent Hashing** এর প্রয়োজন পড়ে।

## 1. সাধারণ হ্যাশিংয়ের সমস্যা (Modulo Hashing)
ধরা যাক আমাদের ৩টি সার্ভার আছে। কোনো ডেটা সেভ করার জন্য আমরা `hash(key) % 3` ব্যবহার করি। 
*   যদি একটি নতুন সার্ভার যোগ করা হয় (৩ থেকে ৪ হয়), তবে সব ডেটার লোকেশন বদলে যাবে (Modulo 4 হবে)। 
*   এর ফলে ক্যাশ মিস (Cache Miss) হয় এবং প্রায় সব ডেটা নতুন করে সার্ভারগুলোর মধ্যে মুভ করতে হয়, যা হাই-ট্রাফিক সিস্টেমে বড় বিপর্যয় ঘটাতে পারে।

## 2. Consistent Hashing কিভাবে কাজ করে?

এই পদ্ধতিতে হ্যাশ স্পেসকে একটি সার্কেল বা আংটির (Ring) মতো চিন্তা করা হয়।

1.  **সার্ভার ম্যাপিং:** প্রথমে সার্ভারগুলোর আইপি বা নামকে হ্যাশ করে এই সার্কেলে বসানো হয়।
2.  **ডেটা ম্যাপিং:** ডেটা বা কী-কে (Key) হ্যাশ করে সার্কেলের ওপর বসানো হয়।
3.  **অ্যাসাইনমেন্ট:** সার্কেলের ওপর বসা ডেটা থেকে ঘড়ির কাঁটার দিকে (Clockwise) ঘুরলে সবার আগে যে সার্ভারটি পাওয়া যাবে, ডেটাটি সেই সার্ভারে সেভ হবে।

## 3. সুবিধা কি?

*   **কম ডেটা মুভমেন্ট:** যদি একটি সার্ভার রিমুভ করা হয় বা নতুন যোগ করা হয়, তবে শুধুমাত্র সেই সার্ভারের কাছে থাকা বা তার পরবর্তী ডেটাগুলোই এফেক্টেড হয়। গড়ে মাত্র `1/n` অংশ ডেটা মুভ করতে হয়।
*   **Scalability:** এটি সিস্টেমকে ডিনামিকালি স্কেল করতে সাহায্য করে কোনো বড় ডাউনটাইম ছাড়াই।

## 4. Virtual Nodes
সহজভাবে ভাগ করলে অনেক সময় একটি সার্ভারে বেশি এবং অন্যটিতে কম ডেটা পড়তে পারে। এটি সমাধান করার জন্য **Virtual Nodes** ব্যবহার করা হয়। একটি ফিজিক্যাল সার্ভারকে সার্কেলের বিভিন্ন জায়গায় রিপ্রেজেন্ট করা হয়, যাতে ডেটা ডিস্ট্রিবিউশন একদম সমান হয়।

---

> [!IMPORTANT]
> লোড ব্যালেন্সার এবং ডিস্ট্রিবিউটেড ডেটাবেস (যেমন: DynamoDB, Cassandra) এবং ক্যাশ সিস্টেমের (যেমন: Redis Cluster) মূলে কাজ করে এই **Consistent Hashing**। বড় স্কেলের সিস্টেম ডিজাইনে এটি একটি 'মাস্ট-নো' (Must-know) কনসেপ্ট।
