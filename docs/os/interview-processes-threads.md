# Processes & Threads Interview Questions

প্রসেস এবং থ্রেড অপারেটিং সিস্টেম ইন্টারভিউয়ের সবচেয়ে গুরুত্বপূর্ণ টপিক। এখানে কমন এবং অ্যাডভান্সড প্রশ্নগুলো কভার করা হলো।

## Theoretical Questions

### Q1: Process এবং Program-এর মধ্যে পার্থক্য কী?

**Answer:**

- **Program:** এটি একটি প্যাসিভ এনটিটি (Passive Entity), যা ডিস্কে স্টোর করা ফাইল (Executable file)। এতে শুধুই ইনস্ট্রাকশন থাকে।
- **Process:** এটি একটি অ্যাক্টিভ এনটিটি (Active Entity), যা প্রোগ্রামের এক্সিকিউশন। যখন একটি প্রোগ্রাম মেমোরিতে লোড হয় এবং রান করা শুরু করে, তখন তা প্রসেস হয়। প্রসেসের নিজস্ব রিসোর্স (CPU registers, Stack, Heap) থাকে।

### Q2: PCB (Process Control Block) কী? এতে কী কী থাকে?

**Answer:**
PCB হলো একটি ডেটা স্ট্রাকচার যা OS প্রতিটি প্রসেসের জন্য মেইনটেইন করে। এটি প্রসেস ম্যানেজমেন্টের জন্য সব তথ্য ধারণ করে।
**Contents:**

1. **Process ID (PID):** প্রসেসের ইউনিক আইডেন্টিফায়ার।
2. **Process State:** (New, Ready, Running, Waiting, Terminated)।
3. **Program Counter:** পরবর্তী কোন ইনস্ট্রাকশন এক্সিকিউট হবে তার অ্যাড্রেস।
4. **CPU Registers:** অ্যাকুমুলেটর, ইনডেক্স রেজিস্টার ইত্যাদির ভ্যালু।
5. **Memory Limits:** Base এবং Limit রেজিস্টার (মেমোরি প্রোটেকশনের জন্য)।
6. **Open Files List:** প্রসেসটি কোন কোন ফাইল ওপেন করেছে।

### Q3: Process States গুলো বর্ণনা করুন।

**Answer:**
একটি প্রসেস তার লাইফসাইকেলে নিচের স্টেটগুলো পার করে:

1. **New:** প্রসেস ক্রিয়েট হচ্ছে।
2. **Ready:** প্রসেস মেমোরিতে আছে এবং CPU-র জন্য অপেক্ষা করছে।
3. **Running:** প্রসেস ইন্সট্রাকশন এক্সিকিউট করছে।
4. **Waiting (Blocked):** I/O বা অন্য কোনো ইভেন্টের জন্য অপেক্ষা করছে।
5. **Terminated:** প্রসেস এক্সিকিউশন শেষ করেছে।
   **(Optional: Suspended Ready, Suspended Wait - যখন মেমোরি ফুল হয়ে যায় এবং প্রসেস সোয়াপ আউট হয়)**

### Q4: Short-term, Medium-term, এবং Long-term Scheduler-এর পার্থক্য কী?

**Answer:**

- **Long-term (Job Scheduler):** ডিস্ক থেকে কোন প্রসেসকে Ready Queue-তে (RAM-এ) আনা হবে তা ঠিক করে। এটি Degree of Multiprogramming নিয়ন্ত্রণ করে। (Slow)।
- **Short-term (CPU Scheduler):** Ready Queue থেকে কোন প্রসেসকে CPU দেওয়া হবে তা ঠিক করে। (Fast - milliseconds)।
- **Medium-term:** মেমোরি ফুল হলে প্রসেসকে RAM থেকে ডিস্কে (Swap out) এবং পরে আবার RAM-এ (Swap in) আনে। Swapping নিয়ন্ত্রণ করে।

### Q5: User-level Thread vs Kernel-level Thread?

**Answer:**

- **User-level Thread:** ইউজার স্পেসে থ্রেড লাইব্রেরি দিয়ে ম্যানেজ হয়। OS কার্নেল জানে না যে থ্রেড আছে, সে পুরো প্রসেসকে একটাই থ্রেড মনে করে। (Fast, but if one thread blocks, entire process blocks)।
- **Kernel-level Thread:** OS কার্নেল নিজেই থ্রেড ম্যানেজ করে। (Slower due to system calls, but independent scheduling possible)।

### Q6: `fork()` সিস্টেম কল কীভাবে কাজ করে?

**Answer:**
`fork()` একটি নতুন চাইল্ড প্রসেস তৈরি করে যা প্যারেন্ট প্রসেসের হুবহু কপি (Duplicate)।

- এটি **একবার কল হয় কিন্তু দুইবার রিটার্ন করে**।
  - প্যারেন্ট প্রসেসে এটি চাইল্ডের **PID** রিটার্ন করে।
  - চাইল্ড প্রসেসে এটি **0** রিটার্ন করে।
- চাইল্ড প্রসেস তার নিজস্ব মেমোরি স্পেস পায় (Copy-on-Write মেকানিজম ব্যবহার করে অপ্টিমাইজড)।

### Q7: `exec()` সিস্টেম কল কেন `fork()`-এর পরে ব্যবহার করা হয়?

**Answer:**
`fork()` প্রসেস ডুপ্লিকেট করে, কিন্তু আমরা সাধারণত চাই নতুন প্রসেস অন্য কোনো কাজ করুক। `exec()` ফ্যামিলি ফাংশন বর্তমান প্রসেসের মেমোরি স্পেসকে একটি নতুন প্রোগ্রাম দিয়ে রিপ্লেস করে দেয়। তাই `fork()` দিয়ে প্রসেস বানিয়ে `exec()` দিয়ে নতুন প্রোগ্রাম রান করা হয়।

## Scenario-Based Questions

### Scenario 1: Chrome vs Firefox Architecture

**Q:** Google Chrome প্রতিটি ট্যাবের জন্য আলাদা প্রসেস ব্যবহার করে, কিন্তু পুরানো Firefox ভার্সন থ্রেড ব্যবহার করত। কেন Chrome প্রসেস মডেল বেছে নিল?
**Answer:**

- **Crash Isolation:** একটি ট্যাবের পেইজ ক্র্যাশ করলে পুরো ব্রাউজার বন্ধ হয় না।
- **Security:** স্যান্ডবক্সিং সহজ হয়। এক ট্যাবের ম্যালওয়্যার অন্য ট্যাবের মেমোরি এক্সেস করতে পারে না।
- **Memory Leak:** ট্যাব বন্ধ করলে পুরো মেমোরি OS রিক্লেইম করতে পারে, যা থ্রেডে কঠিন।
- **Disadvantage:** প্রসেস হেভিওয়েট, তাই Chrome বেশি RAM খায়।

### Scenario 2: Zombie Process Cleanup

**Q:** আপনি দেখলেন সার্ভারে প্রচুর Zombie প্রসেস জমে আছে। আপনি কিভাবে এগুলো কিল করবেন?
**Answer:**
Zombie প্রসেস অলরেডি মৃত, তাই `kill -9 <zombie_pid>` কাজ করবে না।

- একে রিমুভ করতে হলে তার **Parent Process**-কে জানাতে হবে।
- যদি প্যারেন্ট রেসপন্স না করে, তবে প্যারেন্ট প্রসেসকে কিল করতে হবে। তখন `init` প্রসেস (PID 1) ওই জম্বিগুলোর নতুন প্যারেন্ট হবে এবং তাদের ক্লিনআপ করবে।

### Scenario 3: Context Switch Overhead

**Q:** একটি সিস্টেমে যদি দেখেন CPU Usage 100% কিন্তু ইউজার অ্যাপলিকেশন স্লো, এবং `sys` টাইম `user` টাইমের চেয়ে অনেক বেশি, এর কারণ কী হতে পারে?
**Answer:**
এর মানে সিস্টেম বেশিরভাগ সময় **Context Switching** বা কার্নেল মোডে ব্যয় করছে।

- খুব বেশি প্রসেস বা থ্রেড রান করছে (Thrashing হতে পারে)।
- I/O বা ইন্টারাপ্ট স্টর্ম হচ্ছে।
- শিডিউলার খুব ঘন ঘন প্রসেস সুইচ করছে (Time quantum খুব ছোট হলে)।

### Scenario 4: Fork Bomb

**Q:** নিচের কোডটি রান করলে কী হবে?

```c
while(1) fork();
```

**Answer:**
এটি একটি **Fork Bomb**। এটি ইনফিনিট লুপে প্রসেস তৈরি করতে থাকবে যতক্ষণ না সিস্টেমের প্রসেস টেবিলে জায়গা শেষ হয় বা মেমোরি শেষ হয়। সিস্টেম হ্যাং হয়ে যাবে এবং রিবুট ছাড়া উপায় থাকবে না (যদি না `ulimit` দিয়ে প্রসেস লিমিট সেট করা থাকে)।

### Scenario 5: Multithreading on Single Core

**Q:** সিঙ্গেল কোর প্রসেসরে কি মাল্টিথ্রেডিং ফায়দা দেয়?
**Answer:**

- **CPU bound task হলে:** না, বরং কনটেক্সট সুইচিং-এর কারণে স্লো হবে।
- **I/O bound task হলে:** হ্যাঁ, অবশ্যই। কারণ যখন একটি থ্রেড নেটওয়ার্ক বা ডিস্কের জন্য ওয়েট করে, তখন CPU অন্য থ্রেড রান করতে পারে। এতে CPU utilization বাড়ে।
