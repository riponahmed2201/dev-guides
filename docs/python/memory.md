# Memory Management

পাইথনে মেমরি ম্যানেজমেন্ট অটোমেটিক হলেও একজন এক্সপার্ট ডেভেলপারের জানা উচিত ব্যাকগ্রাউন্ডে এটি কিভাবে কাজ করে। এর মাধ্যমে আপনি মেমরি লিক (Memory Leak) ঠেকাতে পারবেন এবং হাই-পারফরম্যান্স অ্যাপ্লিকেশন বানাতে পারবেন।

---

## ১. Reference Counting

পাইথনের মেমরি ম্যানেজমেন্টের প্রধান মেকানিজম হলো **Reference Counting**। যখনই আপনি কোনো অবজেক্ট তৈরি করেন, পাইথন একটি কাউন্টার রাখে যে কতজন ওই অবজেক্টকে রেফারেন্স করছে। যখন কাউন্ট ০ হয়ে যায়, পাইথন অটোমেটিক সেই মেমরি খালি করে দেয়।

```python
import sys

x = [1, 2, 3]
print(sys.getrefcount(x)) # রেফারেন্স কাউন্ট দেখা
```

---

## ২. Garbage Collection (GC)

কখনো কখনো রেফারেন্স কাউন্টিং ফেইল করতে পারে। যেমন- **Cyclic Reference** (একাধিক অবজেক্ট একে অপরকে রেফারেন্স করছে কিন্তু বাইরের কেউ তাদের করছে না)। এসব ক্ষেত্রে পাইথনের বিল্ট-ইন **Garbage Collector** মেমরি ক্লিন করে।

```python
import gc

# ম্যানুয়ালি ক্লিক করা (যদিও প্রয়োজন হয় না)
gc.collect() 
```

---

## ৩. Slots (`__slots__`)

ডিফল্টভাবে পাইথন প্রতিটি অবজেক্টের ভেরিয়েবল রাখার জন্য একটি ডিকশনারি (`__dict__`) ব্যবহার করে, যা অনেক মেমরি খরচ করে। আপনার যদি হাজার হাজার অবজেক্ট থাকে, তবে মেমরি বাঁচাতে `__slots__` ব্যবহার করা উচিত।

```python
class Student:
    __slots__ = ['name', 'roll'] # শুধু এই দুটি ভেরিয়েবল ই থাকবে
    
    def __init__(self, name, roll):
        self.name = name
        self.roll = roll
```

---

## ৪. Generators for Memory Saving

বড় ডেটাসেট নিয়ে কাজ করার সময় লিস্ট ব্যবহার না করে জেনারেটর ব্যবহার করা মেমরি ম্যানেজমেন্টের একটি অন্যতম সেরা প্র্যাকটিস। (বিস্তারিত দেখুন লেভেল ২: [Iterators & Generators](/python/iter-gen))

---

## ৫. Weak References

কখনো কখনো আপনি একটি অবজেক্টকে ট্রাক করতে চান কিন্তু চান না যে তা রেফারেন্স কাউন্ট বাড়াক। এর জন্য **`weakref`** মডিউল ব্যবহার করা হয়। এটি ক্যাশিং (Caching) সিস্টেম তৈরির জন্য খুব প্রয়োজনীয়।

---

::: tip
হাই-পারফরম্যান্স সার্ভার বা বড় ডাটা প্রসেসিং অ্যাপ্লিকেশনে `gc` মডিউল এবং `__slots__` ব্যবহার করে মেমরি ব্যবহারের পরিমাণ অনেক কমিয়ে আনা সম্ভব।
:::
