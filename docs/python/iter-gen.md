# Iterators & Generators

মেমরি ম্যানেজমেন্ট এবং ডেটা নিয়ে স্মার্টলি কাজ করার জন্য **Iterators** এবং **Generators** জানা প্রয়োজন। এগুলো ডেটাকে একসাথে মেমরিতে না রেখে এক এক করে প্রসেস করতে সাহায্য করে।

---

## ১. Iterator Protocol

কোনো অবজেক্টের ওপর লুপ চালানো যাবে কি না তা ঠিক করে এই প্রটোকল। এর জন্য দুটি মেথড প্রয়োজন:
- **`__iter__()`**: যা একটি ইটারেটর অবজেক্ট রিটার্ন করে।
- **`__next__()`**: যা পরবর্তী ভ্যালু রিটার্ন করে।

```python
nums = [1, 2, 3]
it = iter(nums)

print(next(it)) # ১
print(next(it)) # ২
```

---

## ২. Generators (জেনারেটর)

জেনারেটর হলো ফাংশন তৈরির একটি বিশেষ পদ্ধতি যা `return` এর বদলে **`yield`** কি-ওয়ার্ড ব্যবহার করে। এটি পুরো ডাটা মেমরিতে লোড না করে যখন প্রয়োজন তখন একটি করে ডাটা জেনারেট করে।

```python
def my_generator():
    yield 1
    yield 2
    yield 3

gen = my_generator()
for val in gen:
    print(val)
```

---

## ৩. কেন জেনারেটর ব্যবহার করবেন? (Memory Efficiency)

ধরুন আপনার ১ বিলিয়ন ডাটা প্রসেস করতে হবে। আপনি যদি লিস্ট ব্যবহার করেন, তবে আপনার পিসির সব র‍্যাম (RAM) শেষ হয়ে যাবে। কিন্তু জেনারেটর ব্যবহার করলে এটি প্রতিবার শুধু একটি ডাটা মেমরিতে রাখবে।

```python
# মেমরি বাঁচানোর উদাহরণ:
def infinite_sequence():
    num = 0
    while True:
        yield num
        num += 1

# এটি কখনোই মেমরি ফুল করবে না
gen = infinite_sequence()
print(next(gen)) # ০
print(next(gen)) # ১
```

---

## ৪. Generator Expressions

লিস্ট কমপ্রিহেনশনের মতোই এক লাইনে জেনারেটর তৈরি করা যায়। পার্থক্য হলো এখানে থার্ড ব্র্যাকেট `[ ]` এর বদলে ফার্স্ট ব্র্যাকেট `( )` ব্যবহার করা হয়।

```python
nums = [1, 2, 3, 4]
# Generator expression
sq_gen = (x*x for x in nums)

print(next(sq_gen)) # ১
```

---

## ৫. itertools মডিউল

অ্যাডভান্সড ইটারেশনের জন্য পাইথনে `itertools` নামে একটি দুর্দান্ত বিল্ট-ইন মডিউল আছে (যেমন: `count`, `cycle`, `repeat`, `chain`)।

---

::: tip
জেনারেটর হলো **Lazy Evaluation** এর একটি উদাহরণ। অর্থাৎ কাজ তখনি হবে যখন রেজাল্ট চাওয়া হবে।
:::
